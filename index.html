<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Psy_Kick Drama - V 0.1.0</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<script src="presetManager.js"></script> 
  <script src="export.js"></script>
  <script src="title.js"></script>
<script src="effects.js"></script>
  <script src="load.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <pre>██████╗ ███████╗██╗   ██╗        ██╗  ██╗██╗ ██████╗██╗  ██╗    ██████╗ ██████╗  █████╗ ███╗   ███╗ █████╗ 
██╔══██╗██╔════╝╚██╗ ██╔╝        ██║ ██╔╝██║██╔════╝██║ ██╔╝    ██╔══██╗██╔══██╗██╔══██╗████╗ ████║██╔══██╗
██████╔╝███████╗ ╚████╔╝         █████╔╝ ██║██║     █████╔╝     ██║  ██║██████╔╝███████║██╔████╔██║███████║
██╔═══╝ ╚════██║  ╚██╔╝          ██╔═██╗ ██║██║     ██╔═██╗     ██║  ██║██╔══██╗██╔══██║██║╚██╔╝██║██╔══██║
██║     ███████║   ██║   ███████╗██║  ██╗██║╚██████╗██║  ██╗    ██████╔╝██║  ██║██║  ██║██║ ╚═╝ ██║██║  ██║
╚═╝     ╚══════╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝
                                                                                                           </pre>
<div style="display: flex; align-items: center; gap: 10px;">
  <button id="startAudio">Start</button>
  <h1>Psy_Kick Drama - V 0.1.0</h1>
</div>
<h5><span id="pWord">Percussive</span> <span id="sWord">Sequencer</span> <span id="yWord">Yielding</span> <span id="kWord">Khaos</span>. <span id="iWord">Its</span> <span id="cWord">Core</span> <span id="gWord">Gross</span> <span id="dWord">Drumming</span> <span id="rWord">Rhythms</span>, <span id="bWord">bear</span> <span id="mWord">Musical</span> <span id="aWord">Absurdity</span>.</h5>  
 <div class="button-container">
    <button class="custom-button save-button">SAVE PROJECT</button>
    <button class="custom-button load-button">LOAD PROJECT</button>
  </div>  
<div class="pattern-container">
    <h2>Pattern Manager:</h2>
</div>
<div class="pattern-row">
    <div id="patternDisplay">A1</div>
    <input type="text" id="patternNameInput" placeholder="Pattern Name / Description" maxlength="30">
</div>  
<div class="button-row">
  <button id="duplicatePatternButton">NEW MAIN</button>
  <button id="newPatternButton">NEW VARIATION</button>
  <span class="copy-label">COPY PATTERN:</span>
  <div class="copy-toggle copy-all" data-copy="all"></div>
</div>  
<div class="patterns-list"></div>
<h2>Pattern Sequencer:</h2>
 <div id="songSequencerContainer">
  <div class="pattern-row" id="songSequencerRows" data-row="0">
    <button id="songPlayButton"></button> 
    <span class="loop-label">LOOP:</span>
    <div class="loop-toggle" data-state="off"></div>
    <input type="text" class="loop-count-input" value="1">
    <button class="add-row-button">ADD ROW</button>
    <button class="delete-row-button" style="display: none;">DELETE</button>
    <span class="steps-label">STEPS:</span>
    <input type="number" class="song-steps-input" min="0" max="16" step="1" value="0">
  </div>
</div>
<h2>Step Sequencer:</h2>
<div class="bpm-container">
  <div id="sequencerPatternDisplay">A1</div>
  <button id="playButton"></button>
  <label for="bpmInput">BPM:</label>
  <input type="number" id="bpmInput" min="30" max="400" step="1" value="120">
  <label for="stepsInput">STEPS:</label>
  <input type="number" id="stepsInput" min="0" max="32" step="1" value="16">
  <label for="clickMeasuresInput">MEASURES:</label>
  <input type="number" id="clickMeasuresInput" class="click-measures-input" min="1" max="32" step="1" value="4">
  <label for="clickSampleInput">CLICK:</label>
  <div class="click-pad"></div>
  <input type="file" id="clickSampleInput" accept="audio/wav,audio/*" style="display: none;">
</div>
<h5>Drum Sequencer:</h5>  
<div id="sequencer">
<div class="track-row">
<div class="pad" data-sound="kick" data-note="C1">1</div>  
<input type="text" class="name-input" data-sound="kick" value="Kick">
<input type="file" class="sample-input" data-sound="kick" data-note="C1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="kick">L</div>
<input type="number" class="track-steps-input" data-sound="kick" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="kick"></div>
<div class="solo-pad" data-sound="kick">S</div>
<div class="mute-pad" data-sound="kick">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="snare" data-note="D1">2</div>
<input type="text" class="name-input" data-sound="snare" value="Snare">
<input type="file" class="sample-input" data-sound="snare" data-note="D1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="snare">L</div>
<input type="number" class="track-steps-input" data-sound="snare" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="snare"></div>
<div class="solo-pad" data-sound="snare">S</div>
<div class="mute-pad" data-sound="snare">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="hihat" data-note="E1">3</div>
<input type="text" class="name-input" data-sound="hihat" value="Hi-Hat">
<input type="file" class="sample-input" data-sound="hihat" data-note="E1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="hihat">L</div>
<input type="number" class="track-steps-input" data-sound="hihat" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="hihat"></div>
<div class="solo-pad" data-sound="hihat">S</div>
<div class="mute-pad" data-sound="hihat">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="clap" data-note="F1">4</div>
<input type="text" class="name-input" data-sound="clap" value="Clap">
<input type="file" class="sample-input" data-sound="clap" data-note="F1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="clap">L</div>
<input type="number" class="track-steps-input" data-sound="clap" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="clap"></div>
<div class="solo-pad" data-sound="clap">S</div>
<div class="mute-pad" data-sound="clap">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="tom" data-note="G1">5</div>
<input type="text" class="name-input" data-sound="tom" value="Tom">
<input type="file" class="sample-input" data-sound="tom" data-note="G1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="tom">L</div>
<input type="number" class="track-steps-input" data-sound="tom" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="tom"></div>
<div class="solo-pad" data-sound="tom">S</div>
<div class="mute-pad" data-sound="tom">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="rimshot" data-note="A1">6</div>
<input type="text" class="name-input" data-sound="rimshot" value="Rimshot">
<input type="file" class="sample-input" data-sound="rimshot" data-note="A1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="rimshot">L</div>
<input type="number" class="track-steps-input" data-sound="rimshot" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="rimshot"></div>
<div class="solo-pad" data-sound="rimshot">S</div>
<div class="mute-pad" data-sound="rimshot">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="crash" data-note="B1">7</div>
<input type="text" class="name-input" data-sound="crash" value="Crash">
<input type="file" class="sample-input" data-sound="crash" data-note="B1" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="crash">L</div>
<input type="number" class="track-steps-input" data-sound="crash" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="crash"></div>
<div class="solo-pad" data-sound="crash">S</div>
<div class="mute-pad" data-sound="crash">M</div>
</div>
<div class="track-row">
<div class="pad" data-sound="cowbell" data-note="C2">8</div>
<input type="text" class="name-input" data-sound="cowbell" value="Cowbell">
<input type="file" class="sample-input" data-sound="cowbell" data-note="C2" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="cowbell">L</div>
<input type="number" class="track-steps-input" data-sound="cowbell" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="cowbell"></div>
<div class="solo-pad" data-sound="cowbell">S</div>
<div class="mute-pad" data-sound="cowbell">M</div>
</div>
<h5>Sample Sequencer:</h5>   
<div class="track-row">
<div class="pad" data-sound="extra" data-note="D2">9</div>  
<input type="text" class="name-input" data-sound="extra" value="Extra">
<input type="file" class="sample-input" data-sound="extra" data-note="D2" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="extra">L</div>
<input type="number" class="track-steps-input" data-sound="extra" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="extra"></div>
<div class="solo-pad" data-sound="extra">S</div>
<div class="mute-pad" data-sound="extra">M</div>
<div class="extra-mode-toggle" data-mode="step" data-sound="extra" style="display: flex;">STEP</div>  
</div>
<div class="track-row">
<div class="pad" data-sound="extra2" data-note="E2">10</div>  
<input type="text" class="name-input" data-sound="extra2" value="Extra2">
<input type="file" class="sample-input" data-sound="extra2" data-note="E2" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="extra2">L</div>
<input type="number" class="track-steps-input" data-sound="extra2" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="extra2"></div>
<div class="solo-pad" data-sound="extra2">S</div>
<div class="mute-pad" data-sound="extra2">M</div>
<div class="extra-mode-toggle" data-mode="step" data-sound="extra2" style="display: flex;">STEP</div>  
</div>
<div class="track-row">
<div class="pad" data-sound="extra3" data-note="F2">11</div>  
<input type="text" class="name-input" data-sound="extra3" value="Extra3">
<input type="file" class="sample-input" data-sound="extra3" data-note="F2" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="extra3">L</div>
<input type="number" class="track-steps-input" data-sound="extra3" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="extra3"></div>
<div class="solo-pad" data-sound="extra3">S</div>
<div class="mute-pad" data-sound="extra3">M</div>
<div class="extra-mode-toggle" data-mode="step" data-sound="extra3" style="display: flex;">STEP</div> 
</div>
<div class="track-row">
<div class="pad" data-sound="extra4" data-note="G2">12</div>  
<input type="text" class="name-input" data-sound="extra4" value="Extra4">
<input type="file" class="sample-input" data-sound="extra4" data-note="G2" accept="audio/wav,audio/*" style="display: none;">
<div class="lock-pad" data-sound="extra4">L</div>
<input type="number" class="track-steps-input" data-sound="extra4" min="0" max="32" step="1" value="16">
<div class="sequencer" data-track="extra4"></div>
<div class="solo-pad" data-sound="extra4">S</div>
<div class="mute-pad" data-sound="extra4">M</div>
<div class="extra-mode-toggle" data-mode="step" data-sound="extra4" style="display: flex;">STEP</div> 
</div>  
</div>
<h2>Sound Settings:</h2>
<div id="secondarySequencer">
<div class="secondary-track-row">
<div class="subsequencer-toggles">
  <div class="subsequencer-toggle main-toggle selected" data-mode="main"></div>
  <div class="subsequencer-toggle variation-toggle" data-mode="variation"></div>
</div>
<div class="extra-toggle" data-mode="extra" style="display: none; background-color: #909B20;"></div>
<input type="text" class="secondary-name" value="None" readonly>
<div class="mono-poly-toggle" data-mode="mono">MONO</div>
</div>
<div class="secondary-track-row">
  <label for="substepsInput">SUBSTEPS:</label>
  <input type="number" id="substepsInput" min="1" max="32" step="1" value="1">
  <div class="secondary-sequencer" data-track="secondary"></div>
</div>
<div class="secondary-track-row">
  <label for="panInput">PAN:</label>
<input type="range" id="panInput" min="-1" max="1" step="0.01" value="0">
</div>
<div class="secondary-track-row">
<label for="volumeInput">VOLUME:</label>
<input type="range" id="volumeInput" min="0" max="1" step="0.01" value="0.8">
</div>
<div class="secondary-track-row">
<label for="pitchInput">PITCH:</label>
<input type="number" id="pitchInput" min="-24" max="24" step="1" value="0">
<label for="pitchMixInput">PITCH MIX:</label>
<input type="range" id="pitchMixInput" min="0" max="1" step="0.01" value="0">
</div>  
<div class="secondary-track-row">
<label for="distortionInput">DISTORTION:</label>
<input type="range" id="distortionInput" min="0" max="1" step="0.01" value="0">
</div>
</div>
<div class="secondary-track-row delay-controls">
  <label for="delayMixInput">DELAY MIX:</label>
  <input type="range" id="delayMixInput" min="0" max="1" step="0.01" value="0">
  <label for="delayFeedbackInput">FEEDBACK:</label>
  <input type="range" id="delayFeedbackInput" min="0" max="0.9" step="0.01" value="0.3">
  <label for="delayTimeInput">DELAY TIME:</label>
  <input type="range" id="delayTimeInput" min="0" max="15" step="1" value="3">
  <label for="delayFilterInput">DELAY FILTER:</label>
  <input type="range" id="delayFilterInput" min="100" max="10000" step="10" value="5000">
</div>
  <h2>Export:</h2>
  <div class="preset-buttons">
  <button id="exportPatternButton">EXPORT PATTERN</button>
  <button id="exportSongButton">EXPORT SONG</button>
    </div>
    <div class="preset-buttons">
  <label for="saveAllPad">ALL TRACKS:</label>  
    <div class="save-pad saveAllPad" data-state="on" onclick="toggleSavePad('saveAllPad')"></div>
  <label for="saveSelPad">SELECTED TRACKS:</label>  
   <div class="save-pad saveSelPad" data-state="off" onclick="toggleSavePad('saveSelPad')"></div>
     </div> 
<div class="track-toggles">
  <div class="save-pad track-toggle" data-track="kick" data-state="off" onclick="toggleTrackPad('kick')">1</div>
  <div class="save-pad track-toggle" data-track="snare" data-state="off" onclick="toggleTrackPad('snare')">2</div>
  <div class="save-pad track-toggle" data-track="hihat" data-state="off" onclick="toggleTrackPad('hihat')">3</div>
  <div class="save-pad track-toggle" data-track="clap" data-state="off" onclick="toggleTrackPad('clap')">4</div>
  <div class="save-pad track-toggle" data-track="tom" data-state="off" onclick="toggleTrackPad('tom')">5</div>
  <div class="save-pad track-toggle" data-track="rimshot" data-state="off" onclick="toggleTrackPad('rimshot')">6</div>
  <div class="save-pad track-toggle" data-track="crash" data-state="off" onclick="toggleTrackPad('crash')">7</div>
  <div class="save-pad track-toggle" data-track="cowbell" data-state="off" onclick="toggleTrackPad('cowbell')">8</div>
  <div class="save-pad track-toggle" data-track="extra" data-state="off" onclick="toggleTrackPad('extra')">9</div>
  <div class="save-pad track-toggle" data-track="extra2" data-state="off" onclick="toggleTrackPad('extra2')">10</div>
  <div class="save-pad track-toggle" data-track="extra3" data-state="off" onclick="toggleTrackPad('extra3')">11</div>
  <div class="save-pad track-toggle" data-track="extra4" data-state="off" onclick="toggleTrackPad('extra4')">12</div>
</div>  
<script>
  
  const patternBPMs = {
  A1: 120
};

// Cache to store effect nodes for each step
const extraEffectNodesCache = { extra: {} }; // [track][pattern][step] -> {pitchShift, distortion, delay, delayFilter, panner, gain}   
  
let currentPattern = "A1";
let patterns = ["A1"];
let isPlaying = false; // Add this line
const maxPatterns = 128;
const allPatterns = [
  "A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1", "I1", "J1", "K1", "L1", "M1", "N1", "O1", "P1",
  "A2", "B2", "C2", "D2", "E2", "F2", "G2", "H2", "I2", "J2", "K2", "L2", "M2", "N2", "O2", "P2",
  "A3", "B3", "C3", "D3", "E3", "F3", "G3", "H3", "I3", "J3", "K3", "L3", "M3", "N3", "O3", "P3",
  "A4", "B4", "C4", "D4", "E4", "F4", "G4", "H4", "I4", "J4", "K4", "L4", "M4", "N4", "O4", "P4",
  "A5", "B5", "C5", "D5", "E5", "F5", "G5", "H5", "I5", "J5", "K5", "L5", "M5", "N5", "O5", "P5",
  "A6", "B6", "C6", "D6", "E6", "F6", "G6", "H6", "I6", "J6", "K6", "L6", "M6", "N6", "O6", "P6",
  "A7", "B7", "C7", "D7", "E7", "F7", "G7", "H7", "I7", "J7", "K7", "L7", "M7", "N7", "O7", "P7",
  "A8", "B8", "C8", "D8", "E8", "F8", "G8", "H8", "I8", "J8", "K8", "L8", "M8", "N8", "O8", "P8"
];

const subdivisions = [
  { label: "1n", value: 0, time: "1n" },
  { label: "1n.", value: 1, time: "1n." },
  { label: "2n", value: 2, time: "2n" },
  { label: "2n.", value: 3, time: "2n." },
  { label: "4n", value: 4, time: "4n" },
  { label: "4n.", value: 5, time: "4n." },
  { label: "4t", value: 6, time: "4t" },
  { label: "8n", value: 7, time: "8n" },
  { label: "8n.", value: 8, time: "8n." },
  { label: "8t", value: 9, time: "8t" },
  { label: "16n", value: 10, time: "16n" },
  { label: "16n.", value: 11, time: "16n." },
  { label: "16t", value: 12, time: "16t" },
  { label: "32n", value: 13, time: "32n" },
  { label: "32n.", value: 14, time: "32n." },
  { label: "32t", value: 15, time: "32t" }
];
  
tracks.forEach(track => {
  variationSubSequences[track] = {};
  mainSubSequences[track] = {};
  mainSubstepCounts[track] = {};
  variationSubstepCounts[track] = {};
  mainPanning[track] = {};
  variationPanning[track] = {};
  mainVolumes[track] = {};
  variationVolumes[track] = {};
  mainDistortionWet[track] = {};
  variationDistortionWet[track] = {};
  mainDelayMix[track] = {};
  variationDelayMix[track] = {};
  mainDelayFeedback[track] = {};
  variationDelayFeedback[track] = {};
  mainDelayTime[track] = {};
  variationDelayTime[track] = {};
  mainDelayFilterFreq[track] = {};
  variationDelayFilterFreq[track] = {};
  mainMonoPoly[track] = {};
  variationMonoPoly[track] = {};
  mainPitch[track] = {};
  variationPitch[track] = {};
  mainPitchMix[track] = {};
  variationPitchMix[track] = {};
  mainPanners[track] = new Tone.Panner(0).toDestination();
  variationPanners[track] = new Tone.Panner(0).toDestination();
  mainGains[track] = new Tone.Gain(0.8).toDestination();
  variationGains[track] = new Tone.Gain(0.8).toDestination();
  mainDistortions[track] = new Tone.Distortion({ distortion: 0.5, wet: 0 }).toDestination();
  variationDistortions[track] = new Tone.Distortion({ distortion: 0.5, wet: 0 }).toDestination();
  mainDelays[track] = new Tone.FeedbackDelay({ delayTime: subdivisions[4].time, feedback: 0.3, wet: 0 }).toDestination();
  variationDelays[track] = new Tone.FeedbackDelay({ delayTime: subdivisions[4].time, feedback: 0.3, wet: 1 }).toDestination();
  mainDelayGains[track] = new Tone.Gain(0).toDestination();
  variationDelayGains[track] = new Tone.Gain(0).toDestination();
  mainDelayFilters[track] = new Tone.Filter({ frequency: 5000, type: "lowpass" }).toDestination();
  variationDelayFilters[track] = new Tone.Filter({ frequency: 5000, type: "lowpass" }).toDestination();
  mainPitchShifters[track] = new Tone.PitchShift({ pitch: 0, wet: 0 }).toDestination();
  variationPitchShifters[track] = new Tone.PitchShift({ pitch: 0, wet: 0 }).toDestination();
  extraStepSamples[track] = {};
  extraStepSamplers[track] = {};
  extraPanning[track] = {};
  extraVolumes[track] = {};
  extraPitch[track] = {};
  extraPitchMix[track] = {};
  extraDistortionWet[track] = {};
  extraDelayMix[track] = {};
  extraDelayFeedback[track] = {};
  extraDelayTime[track] = {};
  extraDelayFilterFreq[track] = {};
  extraMonoPoly[track] = {};
  if (!extraEffectNodesCache[track]) {
  extraEffectNodesCache[track] = {};
}
allPatterns.forEach(pattern => {
  if (!extraEffectNodesCache[track][pattern]) {
    extraEffectNodesCache[track][pattern] = {};
  }
});
  trackStepCounts[track] = 16;
  trackStepLocks[track] = false;
  trackSoloStates[track] = false;
  trackMuteStates[track] = false;
  samplers[track] = new Tone.Sampler({ urls: {} }).toDestination();
  sequence[track] = {};

  allPatterns.forEach(pattern => {
    variationSubSequences[track][pattern] = Array(32).fill(false);
    variationSubSequences[track][pattern][0] = true;
    variationSubstepCounts[track][pattern] = 1;
    mainSubSequences[track][pattern] = Array(32).fill(false);
    mainSubSequences[track][pattern][0] = true;
    mainSubstepCounts[track][pattern] = 1;
    mainPanning[track][pattern] = 0;
    variationPanning[track][pattern] = 0;
    mainVolumes[track][pattern] = 0.8;
    variationVolumes[track][pattern] = 0.8;
    mainDistortionWet[track][pattern] = 0;
    variationDistortionWet[track][pattern] = 0;
    mainDelayMix[track][pattern] = 0;
    variationDelayMix[track][pattern] = 0;
    mainDelayFeedback[track][pattern] = 0.3;
    variationDelayFeedback[track][pattern] = 0.3;
    mainDelayTime[track][pattern] = 4; // Matches subdivisions[4].time = "4n"
    variationDelayTime[track][pattern] = 4; // Matches subdivisions[4].time = "4n"
    mainDelayFilterFreq[track][pattern] = 5000;
    variationDelayFilterFreq[track][pattern] = 5000;
    mainMonoPoly[track][pattern] = "mono";
    variationMonoPoly[track][pattern] = "mono";
    mainPitch[track][pattern] = 0;
    variationPitch[track][pattern] = 0;
    mainPitchMix[track][pattern] = 0;
    variationPitchMix[track][pattern] = 0;
    extraStepSamples[track][pattern] = Array(32).fill(null);
    extraStepSamplers[track][pattern] = Array(32).fill(null);
    extraPanning[track][pattern] = Array(32).fill(0);
    extraVolumes[track][pattern] = Array(32).fill(0.8);
    extraPitch[track][pattern] = Array(32).fill(0);
    extraPitchMix[track][pattern] = Array(32).fill(1);
    extraDistortionWet[track][pattern] = Array(32).fill(0);
    extraDelayMix[track][pattern] = Array(32).fill(0);
    extraDelayFeedback[track][pattern] = Array(32).fill(0.3);
    extraDelayTime[track][pattern] = Array(32).fill(4); // Matches subdivisions[4].time = "4n"
    extraDelayFilterFreq[track][pattern] = Array(32).fill(5000);
    extraMonoPoly[track][pattern] = "step";
    sequence[track][pattern] = Array(32).fill(false);
  });
});
  
  const loadedSamples = {
  C1: null,
  D1: null,
  E1: null,
  F1: null,
  G1: null,
  A1: null,
  B1: null,
  C2: null,
  D2: null,
  E2: null,
  F2: null,
  G2: null
};
const soundNames = {
  C1: "Empty 1",
  D1: "Empty 2",
  E1: "Empty 3",
  F1: "Empty 4",
  G1: "Empty 5",
  A1: "Empty 6",
  B1: "Empty 7",
  C2: "Empty 8",
  D2: "Sampler 1",
  E2: "Sampler 2",
  F2: "Sampler 3",
  G2: "Sampler 4"
};

document.getElementById('startAudio').addEventListener('click', function() {
  document.querySelector('pre').classList.toggle('active-logo');
});  
  
function createPatternBoxes() {
  const patternsList = document.querySelector(".patterns-list");
  patternsList.innerHTML = ""; 
  allPatterns.forEach(pattern => {
    const box = document.createElement("div");
    box.className = `pattern-box ${patterns.includes(pattern) ? "" : "deactivated"} ${pattern === currentPattern ? "selected" : ""}`;
    box.dataset.pattern = pattern;
    box.dataset.tooltip = `Select pattern ${pattern}`;
    box.textContent = pattern;
    patternsList.appendChild(box);
  });
}

createPatternBoxes();

function updatePatternsList() {
  const patternsList = document.querySelector(".patterns-list");
  allPatterns.forEach(pattern => {
    const patternBox = patternsList.querySelector(`.pattern-box[data-pattern="${pattern}"]`);
    patternBox.classList.toggle("deactivated", !patterns.includes(pattern));
    patternBox.classList.toggle("selected", pattern === currentPattern);
    patternBox.addEventListener("click", () => {
      if (!patterns.includes(pattern)) return;
      currentPattern = pattern;
      ["extra", "extra2", "extra3", "extra4"].forEach(track => {
  const toggle = document.querySelector(`.extra-mode-toggle[data-sound="${track}"]`);
  if (toggle) {
    const mode = extraMonoPoly[track][currentPattern] || "step";
    toggle.dataset.mode = mode;
    toggle.textContent = mode.toUpperCase();
  }
});
      updatePatternDisplay();
      document.querySelectorAll(".pattern-box").forEach(box => {
        box.classList.toggle("selected", box.dataset.pattern === pattern);
      });
      
      tracks.forEach(track => {
        const stepCount = patternStepCounts[track][currentPattern] || 16;
        trackStepCounts[track] = stepCount;
        document.querySelector(`.track-steps-input[data-sound="${track}"]`).value = stepCount;
        updateTrackSteps(track, stepCount);
        if (track === selectedSound) {
          updateSubSteps(track);
          updateSoundSettingsUI();
        }
      });

      const firstUnlockedTrack = tracks.find(track => !trackStepLocks[track]);
      stepsInput.value = firstUnlockedTrack ? patternStepCounts[firstUnlockedTrack][currentPattern] || 16 : 16;
      const bpm = patternBPMs[currentPattern] || 120;
      bpmInput.value = bpm;
      Tone.Transport.bpm.value = bpm;
      measures = patternMeasures[currentPattern] || 4;
      clickMeasuresInput.value = measures;
      updateClickUI();
            document.getElementById("patternNameInput").value = patternTexts[pattern] || "";
    });
  });
}

document.getElementById("newPatternButton").addEventListener("click", addVariationPattern);
document.getElementById("duplicatePatternButton").addEventListener("click", addMainPattern);

updatePatternsList();

document.getElementById("patternNameInput").addEventListener("input", function() {
  patternTexts[currentPattern] = this.value;
});

let copyAll = false;
document.querySelector(".copy-toggle").addEventListener("click", () => {
  copyAll = !copyAll;
  document.querySelector(".copy-toggle").classList.toggle("active", copyAll);
});  

const clickSynth = new Tone.MetalSynth({
  frequency: 200,
  envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 },
  harmonicity: 5.1
}).toDestination();
const accentClickSynth = new Tone.MembraneSynth({
  frequency: 1200,
  pitchDecay: 0.05,
  octaves: 2,
  envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.01 }
}).toDestination();

let clickSample = null;
let clickSampler = new Tone.Sampler({
  urls: {},
  onerror: (error) => console.error(`Click sampler failed to load: ${error}`)
}).toDestination();
  
// Initialize variationSubSequences for all tracks and patterns
tracks.forEach(track => {
  if (!variationSubSequences[track]) {
    variationSubSequences[track] = {};
  }
  if (!variationSubSequences[track][currentPattern]) {
    variationSubSequences[track][currentPattern] = Array(32).fill(false);
    variationSubSequences[track][currentPattern][0] = true;
  }
});

// Define data structures for extra track subsequencer
const extraSubSequences = { extra: {} }; // Stores subsequences for extra track steps [track][pattern][step][index]
const extraSubstepCounts = { extra: {} }; // Stores substep counts for extra track steps [track][pattern][step]
// Cache to store effect nodes for each step
   
// Initialize extra track subsequencer data for a pattern
function initializeExtraSubSequence(track, pattern, step) {
    if (!["extra", "extra2", "extra3", "extra4"].includes(track)) return;
  
  // Initialize extraSubSequences
  if (!extraSubSequences[track]) {
    extraSubSequences[track] = {};
  }
  if (!extraSubSequences[track][pattern]) {
    extraSubSequences[track][pattern] = {};
  }
  if (!extraSubSequences[track][pattern][step]) {
    extraSubSequences[track][pattern][step] = Array(32).fill(false);
    extraSubSequences[track][pattern][step][0] = true;
  }
  
  // Initialize extraSubstepCounts
  if (!extraSubstepCounts[track]) {
    extraSubstepCounts[track] = {};
  }
  if (!extraSubstepCounts[track][pattern]) {
    extraSubstepCounts[track][pattern] = {};
  }
  if (!extraSubstepCounts[track][pattern][step]) {
    extraSubstepCounts[track][pattern][step] = 1;
  }
}
  
let selectedSound = null;
let isVariationSubsequencer = false;

let clickActive = false;
let measures = 4;
let globalStepIndex = 0;
  
let activeExtraPlayers = {};  
  
const patternMeasures = {
  A1: 4
};  

const notes = ["C1", "D1", "E1", "F1", "G1", "A1", "B1", "C2", "D2", "E2", "F2", "G2"];
const sequencerDiv = document.getElementById("sequencer");
tracks.forEach(track => {
  const trackDiv = sequencerDiv.querySelector(`[data-track="${track}"]`);
  for (let i = 0; i < 32; i++) {
    const step = document.createElement("div");
    step.className = "step";
    step.classList.toggle("enabled", i < trackStepCounts[track]);
    step.dataset.track = track;
    step.dataset.step = i;
    step.dataset.tooltip = "Left: Toggle main sound (red), Right: Toggle variation sound (light blue)";
    step.innerText = i + 1;
    step.addEventListener("click", () => toggleStep(track, i, false));
    step.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      toggleStep(track, i, true);
    });
    trackDiv.appendChild(step);
  }
});
  
// Modified handleExtraStepSample function
function handleExtraStepSample(track, step, file) {
  if (!["extra", "extra2", "extra3", "extra4"].includes(track) || !file || !file.type.startsWith("audio/")) {
    alert(`Skipped ${file ? file.name : "unknown"}: Not an audio file or not an extra track`);
    return;
  }
  const url = URL.createObjectURL(file);
  extraStepSamples[track][currentPattern][step] = file.name;
  if (!activeExtraPlayers[track]) activeExtraPlayers[track] = {};
  if (!activeExtraPlayers[track][step]) activeExtraPlayers[track][step] = [];

  // Dispose of existing player if it exists
  if (extraStepSamplers[track][currentPattern][step]) {
    extraStepSamplers[track][currentPattern][step].dispose();
    extraStepSamplers[track][currentPattern][step] = null;
  }

  extraStepSamplers[track][currentPattern][step] = new Tone.Player({
    url: url,
    autostart: false,
    onload: () => {
      console.log(`Sample loaded for ${track} track, step ${step}`);
      URL.revokeObjectURL(url); // Revoke URL after loading
      const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
      stepEl.dataset.sampleLoaded = "true";
      const isMeasureStep = step % measures === 0 && stepEl.classList.contains("enabled");
      stepEl.classList.toggle("measure-highlight", isMeasureStep && !sequence[track][currentPattern][step] && !clickActive);
      stepEl.classList.toggle("measure-highlight-active", isMeasureStep && !sequence[track][currentPattern][step] && clickActive);

      // Check if cached effect nodes exist for this step
      if (!extraEffectNodesCache[track][currentPattern]) {
        extraEffectNodesCache[track][currentPattern] = {};
      }
      if (!extraEffectNodesCache[track][currentPattern][step]) {
        extraEffectNodesCache[track][currentPattern][step] = {
          pitchShift: new Tone.PitchShift({ pitch: extraPitch[track][currentPattern][step] || 0, wet: extraPitchMix[track][currentPattern][step] || 1 }),
          distortion: new Tone.Distortion({ distortion: 0.5, wet: extraDistortionWet[track][currentPattern][step] || 0 }),
          delay: new Tone.FeedbackDelay({
            delayTime: subdivisions[extraDelayTime[track][currentPattern][step] || 3]?.time || "4n",
            feedback: extraDelayFeedback[track][currentPattern][step] || 0.3,
            wet: extraDelayMix[track][currentPattern][step] || 0
          }),
          delayFilter: new Tone.Filter({ frequency: extraDelayFilterFreq[track][currentPattern][step] || 5000, type: "lowpass" }),
          panner: new Tone.Panner(extraPanning[track][currentPattern][step] || 0),
          gain: new Tone.Gain(extraVolumes[track][currentPattern][step] || 0.8)
        };
      }

      // Get cached effect nodes
      const { pitchShift, distortion, delay, delayFilter, panner, gain } = extraEffectNodesCache[track][currentPattern][step];

      // Update effect parameters
      pitchShift.pitch = extraPitch[track][currentPattern][step] || 0;
      pitchShift.wet.setValueAtTime(extraPitchMix[track][currentPattern][step] || 1, Tone.now());
      distortion.wet.setValueAtTime(extraDistortionWet[track][currentPattern][step] || 0, Tone.now());
      delay.delayTime.setValueAtTime(subdivisions[extraDelayTime[track][currentPattern][step] || 3]?.time || "4n", Tone.now());
      delay.feedback.setValueAtTime(extraDelayFeedback[track][currentPattern][step] || 0.3, Tone.now());
      delay.wet.setValueAtTime(extraDelayMix[track][currentPattern][step] || 0, Tone.now());
      delayFilter.frequency.setValueAtTime(extraDelayFilterFreq[track][currentPattern][step] || 5000, Tone.now());
      panner.pan.setValueAtTime(extraPanning[track][currentPattern][step] || 0, Tone.now());
      gain.gain.setValueAtTime(extraVolumes[track][currentPattern][step] || 0.8, Tone.now());

      // Connect the player to the cached effect chain
      extraStepSamplers[track][currentPattern][step].chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);

      updateSoundSettingsUI();
    },
    onerror: (error) => {
      console.error(`Failed to load sample for ${track} track, step ${step}: ${error}`);
      extraStepSamples[track][currentPattern][step] = null;
      extraStepSamplers[track][currentPattern][step] = null;
      activeExtraPlayers[track][step] = [];
      URL.revokeObjectURL(url); // Revoke URL on error
    }
  });
}

function handleExtraToggleSample(track, file) {
  if (!["extra", "extra2", "extra3", "extra4"].includes(track) || !file || !file.type.startsWith("audio/")) {
    alert(`Skipped ${file ? file.name : "unknown"}: Not an audio file or not an extra track`);
    return;
  }
  const url = URL.createObjectURL(file);
  const stepCount = trackStepCounts[track] || 16;
  for (let step = 0; step < stepCount; step++) {
    if (!extraStepSamples[track][currentPattern][step]) { // Only load into empty steps
      extraStepSamples[track][currentPattern][step] = file.name;
      // Dispose of any existing player to avoid conflicts
      if (extraStepSamplers[track][currentPattern][step]) {
        extraStepSamplers[track][currentPattern][step].dispose();
        extraStepSamplers[track][currentPattern][step] = null;
      }
      extraStepSamplers[track][currentPattern][step] = new Tone.Player({
        url: url,
        autostart: false,
        onload: () => {
          console.log(`Sample loaded for ${track} track, step ${step}`);
          URL.revokeObjectURL(url); // Revoke URL after loading
          const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
          stepEl.dataset.sampleLoaded = "true";
          const isMeasureStep = step % measures === 0 && stepEl.classList.contains("enabled");
          stepEl.classList.toggle("measure-highlight", isMeasureStep && !sequence[track][currentPattern][step] && !clickActive);
          stepEl.classList.toggle("measure-highlight-active", isMeasureStep && !sequence[track][currentPattern][step] && clickActive);

          const pitchShift = new Tone.PitchShift({
            pitch: extraPitch[track][currentPattern][step] || 0,
            wet: extraPitchMix[track][currentPattern][step] || 1
          });
          const distortion = new Tone.Distortion({
            distortion: 0.5,
            wet: extraDistortionWet[track][currentPattern][step] || 0
          });
          const delay = new Tone.FeedbackDelay({
            delayTime: subdivisions[extraDelayTime[track][currentPattern][step] || 3]?.time || "4n",
            feedback: extraDelayFeedback[track][currentPattern][step] || 0.3,
            wet: extraDelayMix[track][currentPattern][step] || 0
          });
          const delayFilter = new Tone.Filter({
            frequency: extraDelayFilterFreq[track][currentPattern][step] || 5000,
            type: "lowpass"
          });
          const panner = new Tone.Panner(extraPanning[track][currentPattern][step] || 0);
          const gain = new Tone.Gain(extraVolumes[track][currentPattern][step] || 0.8);
          extraEffectNodesCache[track][currentPattern][step] = { pitchShift, distortion, delay, delayFilter, panner, gain };
          extraStepSamplers[track][currentPattern][step].chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);

          // Initialize subsequencer data for the step
          initializeExtraSubSequence(track, currentPattern, step);
          if (selectedExtraStep === step) {
            updateSubSteps(track);
            updateSoundSettingsUI();
          }
        },
        onerror: (error) => {
          console.error(`Failed to load sample for ${track} track, step ${step}: ${error}`);
          extraStepSamples[track][currentPattern][step] = null;
          extraStepSamplers[track][currentPattern][step] = null;
          URL.revokeObjectURL(url); // Revoke URL on error
        }
      });
    }
  }
}
  
document.querySelectorAll(`.sample-input[data-sound="extra"], .sample-input[data-sound="extra2"], .sample-input[data-sound="extra3"], .sample-input[data-sound="extra4"]`).forEach(input => {
  input.addEventListener("change", (e) => {
    const file = e.target.files[0];
    const step = e.target.dataset.step;
    const track = e.target.dataset.sound;
    if (file && step !== undefined && !isNaN(parseInt(step))) {
      handleExtraStepSample(track, parseInt(step), file);
    } else if (file) {
      handleExtraToggleSample(track, file);
    }
    e.target.value = "";
    delete e.target.dataset.step;
  });
});
  
const secondarySequencerDiv = document.getElementById("secondarySequencer");
const secondaryTrackDiv = secondarySequencerDiv.querySelector(`[data-track="secondary"]`);
secondaryTrackDiv.innerHTML = "";
for (let i = 0; i < 32; i++) {
  const step = document.createElement("div");
  step.className = "secondary-step";
  step.dataset.track = "secondary";
  step.dataset.step = i;
  step.dataset.tooltip = "Toggle substep for current subsequencer mode";
  step.innerText = i + 1;
  step.addEventListener("click", () => toggleSubStep(i));
  secondaryTrackDiv.appendChild(step);
}

function updateSubsequencerUI(track, isVariation, pattern) {
  const subSequence = isVariation ? variationSubSequences[track][pattern] : mainSubSequences[track][pattern];
  const substepCount = isVariation ? variationSubstepCounts[track][pattern] : mainSubstepCounts[track][pattern];
  const secondaryTrackDiv = document.querySelector(`[data-track="secondary"]`);
  const steps = secondaryTrackDiv.querySelectorAll(".secondary-step");

  if (!subSequence) {
    const newSequence = Array(32).fill(false);
    newSequence[0] = true; 
    if (isVariation) {
      variationSubSequences[track][pattern] = newSequence;
    } else {
      mainSubSequences[track][pattern] = newSequence;
    }
  }

  steps.forEach((step, i) => {
    if (!step) return; 
    const isEnabled = i < substepCount;
    step.classList.toggle("enabled", isEnabled);
    step.classList.toggle("active", subSequence?.[i] && isEnabled);
    step.classList.toggle("main-active", subSequence?.[i] && isEnabled && !isVariation);
    step.classList.toggle("variation-active", subSequence?.[i] && isEnabled && isVariation);
  });

  document.getElementById("substepsInput").value = substepCount;
}

const subsequencerToggles = document.querySelectorAll(".subsequencer-toggle");
subsequencerToggles.forEach(toggle => {
  toggle.addEventListener("click", async () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    if (!selectedSound) {
      alert("Please select a sound first by clicking a track's pad!");
      return;
    }
    isVariationSubsequencer = toggle.dataset.mode === "variation";
    
    document.querySelectorAll(".subsequencer-toggle").forEach(t => {
      if (t && t.dataset && t.dataset.mode) {
        const isSelected = t.dataset.mode === (isVariationSubsequencer ? "variation" : "main");
        t.classList.toggle("selected", isSelected);
        t.classList.toggle("main-active", t.dataset.mode === "main" && !isVariationSubsequencer);
        t.classList.toggle("variation-active", t.dataset.mode === "variation" && isVariationSubsequencer);
      }
    });

    if (!isVariationSubsequencer) {
      mainPanning[selectedSound][currentPattern] = mainPanning[selectedSound][currentPattern] ?? 0;
      mainVolumes[selectedSound][currentPattern] = mainVolumes[selectedSound][currentPattern] ?? 0.8;
      mainDistortionWet[selectedSound][currentPattern] = mainDistortionWet[selectedSound][currentPattern] ?? 0;
      mainDelayMix[selectedSound][currentPattern] = mainDelayMix[selectedSound][currentPattern] ?? 0;
      mainDelayFeedback[selectedSound][currentPattern] = mainDelayFeedback[selectedSound][currentPattern] ?? 0.3;
      mainDelayTime[selectedSound][currentPattern] = mainDelayTime[selectedSound][currentPattern] ?? 3;
      mainDelayFilterFreq[selectedSound][currentPattern] = mainDelayFilterFreq[selectedSound][currentPattern] ?? 5000;
      mainMonoPoly[selectedSound][currentPattern] = mainMonoPoly[selectedSound][currentPattern] ?? "mono";
      if (!mainSubSequences[selectedSound][currentPattern]) {
        mainSubSequences[selectedSound][currentPattern] = Array(32).fill(false);
        mainSubSequences[selectedSound][currentPattern][0] = true;
        mainSubstepCounts[selectedSound][currentPattern] = 1;
      }
    } else {
      variationPanning[selectedSound][currentPattern] = variationPanning[selectedSound][currentPattern] ?? 0;
      variationVolumes[selectedSound][currentPattern] = variationVolumes[selectedSound][currentPattern] ?? 0.8;
      variationDistortionWet[selectedSound][currentPattern] = variationDistortionWet[selectedSound][currentPattern] ?? 0;
      variationDelayMix[selectedSound][currentPattern] = variationDelayMix[selectedSound][currentPattern] ?? 0;
      variationDelayFeedback[selectedSound][currentPattern] = variationDelayFeedback[selectedSound][currentPattern] ?? 0.3;
      variationDelayTime[selectedSound][currentPattern] = variationDelayTime[selectedSound][currentPattern] ?? 3;
      variationDelayFilterFreq[selectedSound][currentPattern] = variationDelayFilterFreq[selectedSound][currentPattern] ?? 5000;
      variationMonoPoly[selectedSound][currentPattern] = variationMonoPoly[selectedSound][currentPattern] ?? "mono";
      if (!variationSubSequences[selectedSound][currentPattern]) {
        variationSubSequences[selectedSound][currentPattern] = Array(32).fill(false);
        variationSubSequences[selectedSound][currentPattern][0] = true;
        variationSubstepCounts[selectedSound][currentPattern] = 1;
      }
    }

    updateSubSteps(selectedSound);
    updateSoundSettingsUI();
    refreshPannerConnections(selectedSound, isVariationSubsequencer);

    const sliders = [
      panInput, volumeInput, distortionInput, delayMixInput,
      delayFeedbackInput, delayTimeInput, delayFilterInput, pitchMixInput
    ];
    sliders.forEach(slider => {
      if (slider) {
        slider.classList.toggle("main-mode", !isVariationSubsequencer);
        slider.classList.toggle("variation-mode", isVariationSubsequencer);
      }
    });

    const note = notes[tracks.indexOf(selectedSound)];
    const panner = isVariationSubsequencer ? variationPanners[selectedSound] : mainPanners[selectedSound];
    const gain = isVariationSubsequencer ? variationGains[selectedSound] : mainGains[selectedSound];
    const distortion = isVariationSubsequencer ? variationDistortions[selectedSound] : mainDistortions[selectedSound];
    const delay = isVariationSubsequencer ? variationDelays[selectedSound] : mainDelays[selectedSound];
    const filter = isVariationSubsequencer ? variationDelayFilters[selectedSound] : mainDelayFilters[selectedSound];
    const pitchShift = isVariationSubsequencer ? variationPitchShifters[selectedSound] : mainPitchShifters[selectedSound];
    const panValue = isVariationSubsequencer ? variationPanning[selectedSound][currentPattern] : mainPanning[selectedSound][currentPattern];
    const volumeValue = isVariationSubsequencer ? variationVolumes[selectedSound][currentPattern] : mainVolumes[selectedSound][currentPattern];
    const distortionValue = isVariationSubsequencer ? variationDistortionWet[selectedSound][currentPattern] : mainDistortionWet[selectedSound][currentPattern];
    const delayMixValue = isVariationSubsequencer ? variationDelayMix[selectedSound][currentPattern] : mainDelayMix[selectedSound][currentPattern];
    const delayFeedbackValue = isVariationSubsequencer ? variationDelayFeedback[selectedSound][currentPattern] : mainDelayFeedback[selectedSound][currentPattern];
    const delayTimeValue = isVariationSubsequencer ? variationDelayTime[selectedSound][currentPattern] : mainDelayTime[selectedSound][currentPattern];
    const delayFilterValue = isVariationSubsequencer ? variationDelayFilterFreq[selectedSound][currentPattern] : mainDelayFilterFreq[selectedSound][currentPattern];
    const pitchValue = isVariationSubsequencer ? variationPitch[selectedSound][currentPattern] : mainPitch[selectedSound][currentPattern];
    const pitchMixValue = isVariationSubsequencer ? variationPitchMix[selectedSound][currentPattern] : mainPitchMix[selectedSound][currentPattern];
    const playMode = isVariationSubsequencer ? variationMonoPoly[selectedSound][currentPattern] : mainMonoPoly[selectedSound][currentPattern];
    const subSequence = isVariationSubsequencer ? variationSubSequences[selectedSound][currentPattern] : mainSubSequences[selectedSound][currentPattern];
    const substepCount = isVariationSubsequencer ? variationSubstepCounts[selectedSound][currentPattern] : mainSubstepCounts[selectedSound][currentPattern];

    panner.pan.setValueAtTime(panValue, Tone.now());
    gain.gain.setValueAtTime(volumeValue, Tone.now());
    distortion.wet.setValueAtTime(distortionValue, Tone.now());
    delay.wet.setValueAtTime(1, Tone.now());
    delay.feedback.setValueAtTime(delayFeedbackValue, Tone.now());
    delay.delayTime.setValueAtTime(subdivisions[delayTimeValue]?.time || "4n", Tone.now());
    filter.frequency.setValueAtTime(delayFilterValue, Tone.now());
    pitchShift.pitch = pitchValue;
    pitchShift.wet.setValueAtTime(pitchMixValue, Tone.now());

    if (substepCount < 1 || substepCount > 32) {
      console.error(`Invalid substepCount for ${selectedSound}: ${substepCount}`);
      return;
    }
    const quarterNoteDuration = 60 / Tone.Transport.bpm.value;
    const substepDuration = quarterNoteDuration / substepCount;
    let noteDuration = substepCount === 3 ? "8t" : substepCount === 8 ? "32n" : substepCount === 16 ? "64n" : Tone.Time(quarterNoteDuration / substepCount).toNotation();
    if (!noteDuration || noteDuration === "NaN" || isNaN(Tone.Time(noteDuration).toSeconds())) {
      console.warn(`Invalid noteDuration for ${selectedSound}: ${noteDuration}, using default "4n"`);
      noteDuration = "4n";
    }

    if (loadedSamples[note] && samplers[selectedSound].loaded) {
      for (let j = 0; j < substepCount; j++) {
        if (subSequence[j]) {
          const subTime = Tone.now() + j * substepDuration;
          const substepEl = secondaryTrackDiv.querySelector(`[data-step="${j}"]`);
          if (substepEl) {
            substepEl.classList.add("active");
            substepEl.classList.toggle("main-active", !isVariationSubsequencer);
            substepEl.classList.toggle("variation-active", isVariationSubsequencer);
            setTimeout(() => {
              if (substepEl) {
                substepEl.classList.toggle("active", subSequence[j]);
                substepEl.classList.toggle("main-active", subSequence[j] && !isVariationSubsequencer);
                substepEl.classList.toggle("variation-active", subSequence[j] && isVariationSubsequencer);
              }
            }, substepDuration * 1000);
          }

          if (playMode === "mono") {
            samplers[selectedSound].triggerRelease(subTime);
            samplers[selectedSound].triggerAttackRelease(note, noteDuration, subTime);
          } else if (playMode === "poly") {
            samplers[selectedSound].triggerAttack(note, subTime);
          } else if (playMode === "full") {
            const sampleUrl = loadedSamples[note];
            if (sampleUrl) {
              const player = new Tone.Player({
                url: sampleUrl,
                autostart: false,
                volume: volumeValue,
                onload: () => {
                  player.start(subTime);
                  player.onended = () => {
                    if (player.state === "started") {
                      player.stop();
                    }
                    player.dispose();
                  };
                },
                onerror: (error) => console.error(`Failed to load sample for ${selectedSound}: ${error}`)
              });
              player.chain(panner, gain, pitchShift, distortion, delay);
            }
          }
        }
      }
    }
    toggle.classList.add("active");
    setTimeout(() => toggle.classList.remove("active"), 100);
  });
});

const monoPolyToggle = document.querySelector(".mono-poly-toggle");
  
monoPolyToggle.addEventListener("click", () => {
  if (!audioStarted || !selectedSound) {
    alert("Please click 'Start Audio' and select a sound first!");
    return;
  }
  let currentMode = monoPolyToggle.dataset.mode;
  let newMode;
  if (currentMode === "mono") {
    newMode = "poly";
  } else if (currentMode === "poly") {
    newMode = "full";
  } else {
    newMode = "mono";
  }
  monoPolyToggle.dataset.mode = newMode;
  monoPolyToggle.textContent = newMode.toUpperCase();
  monoPolyToggle.classList.toggle("poly", newMode === "poly");
  monoPolyToggle.classList.toggle("full", newMode === "full");
  if (isVariationSubsequencer) {
    variationMonoPoly[selectedSound][currentPattern] = newMode;
  } else {
    mainMonoPoly[selectedSound][currentPattern] = newMode;
  }
});

document.querySelectorAll(".extra-mode-toggle").forEach(toggle => {
  toggle.addEventListener("click", () => {
    const track = toggle.dataset.sound;
    if (!audioStarted || !["extra", "extra2", "extra3", "extra4"].includes(track)) return;
    let currentMode = toggle.dataset.mode;
    let newMode;
    if (currentMode === "step") {
      newMode = "next";
    } else if (currentMode === "next") {
      newMode = "full";
    } else {
      newMode = "step";
    }
    toggle.dataset.mode = newMode;
    toggle.textContent = newMode.toUpperCase();
    extraMonoPoly[track][currentPattern] = newMode;
  });
});
  
panInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  const panValue = parseFloat(panInput.value);
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraPanning[selectedSound][currentPattern][selectedExtraStep] = panValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const { panner } = extraEffectNodesCache[selectedSound][currentPattern][selectedExtraStep];
      panner.pan.setValueAtTime(panValue, Tone.now());
    }
  } else if (isVariationSubsequencer) {
    variationPanning[selectedSound][currentPattern] = panValue;
    variationPanners[selectedSound].pan.value = panValue;
  } else {
    mainPanning[selectedSound][currentPattern] = panValue;
    mainPanners[selectedSound].pan.value = panValue;
  }
});
panInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  panInput.value = 0;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraPanning[selectedSound][currentPattern][selectedExtraStep] = 0;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const panner = new Tone.Panner(0).toDestination();
      player.connect(panner);
    }
  } else if (isVariationSubsequencer) {
    variationPanning[selectedSound][currentPattern] = 0;
    variationPanners[selectedSound].pan.value = 0;
  } else {
    mainPanning[selectedSound][currentPattern] = 0;
    mainPanners[selectedSound].pan.value = 0;
  }
});

volumeInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  const volumeValue = parseFloat(volumeInput.value);
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraVolumes[selectedSound][currentPattern][selectedExtraStep] = volumeValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.volume.value = Tone.gainToDb(volumeValue);
    }
  } else if (isVariationSubsequencer) {
    variationVolumes[selectedSound][currentPattern] = volumeValue;
    variationGains[selectedSound].gain.value = volumeValue;
  } else {
    mainVolumes[selectedSound][currentPattern] = volumeValue;
    mainGains[selectedSound].gain.value = volumeValue;
  }
});
volumeInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  volumeInput.value = 0.8;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraVolumes[selectedSound][currentPattern][selectedExtraStep] = 0.8;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.volume.value = Tone.gainToDb(0.8);
    }
  } else if (isVariationSubsequencer) {
    variationVolumes[selectedSound][currentPattern] = 0.8;
    variationGains[selectedSound].gain.value = 0.8;
  } else {
    mainVolumes[selectedSound][currentPattern] = 0.8;
    mainGains[selectedSound].gain.value = 0.8;
  }
});

const distortionInput = document.getElementById("distortionInput");
distortionInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  const distortionValue = parseFloat(distortionInput.value);
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] = distortionValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: distortionValue
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDistortionWet[selectedSound][currentPattern] = distortionValue;
    variationDistortions[selectedSound].wet.value = distortionValue;
  } else {
    mainDistortionWet[selectedSound][currentPattern] = distortionValue;
    mainDistortions[selectedSound].wet.value = distortionValue;
  }
});

distortionInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  distortionInput.value = 0;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] = 0;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDistortionWet[selectedSound][currentPattern] = 0;
    variationDistortions[selectedSound].wet.value = 0;
  } else {
    mainDistortionWet[selectedSound][currentPattern] = 0;
    mainDistortions[selectedSound].wet.value = 0;
  }
});

let audioStarted = false;
async function initAudio() {
  try {
    if (!audioStarted) {
      if (typeof Tone === "undefined") {
        alert("Tone.js failed to load. Please check your internet connection or try refreshing.");
        console.error("Tone.js is not defined.");
        return;
      }
      await Tone.start();
      audioStarted = true;
      document.getElementById("startAudio").classList.add("active");
      document.getElementById("startAudio").innerText = "On";
      document.querySelectorAll(".pad, .lock-pad, .solo-pad, .mute-pad, .click-pad, .subsequencer-toggle, .mono-poly-toggle, #playButton").forEach(el => el.style.display = "flex");
      tracks.forEach(track => refreshPannerConnections(track, false));
    }
  } catch (error) {
    console.error("Failed to start AudioContext:", error);
    alert("Failed to start audio. Please try again or check the console for details.");
  }
}

document.getElementById("startAudio").addEventListener("click", initAudio);

let selectedExtraStep = null;
  
let isDKeyPressed = false;

document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "d") {
    isDKeyPressed = true;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key.toLowerCase() === "d") {
    isDKeyPressed = false;
  }
});  
  
let isCKeyPressed = false;
let isVKeyPressed = false;
let copiedStepSettings = null;

document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "c") {
    isCKeyPressed = true;
  } else if (e.key.toLowerCase() === "v") {
    isVKeyPressed = true;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key.toLowerCase() === "c") {
    isCKeyPressed = false;
  } else if (e.key.toLowerCase() === "v") {
    isVKeyPressed = false;
  }
});  
  
function removeExtraStepSample(track, step) {
  if (!["extra", "extra2", "extra3", "extra4"].includes(track) || !extraStepSamples[track][currentPattern][step]) return;

  extraStepSamples[track][currentPattern][step] = null;
  if (extraStepSamplers[track][currentPattern][step]) {
    extraStepSamplers[track][currentPattern][step].dispose();
    extraStepSamplers[track][currentPattern][step] = null;
  }
  if (activeExtraPlayers[track] && activeExtraPlayers[track][step]) {
    activeExtraPlayers[track][step].forEach(p => {
      if (p.state === "started") p.stop();
      p.dispose();
    });
    activeExtraPlayers[track][step] = [];
  }
  // Dispose of effect nodes
  if (extraEffectNodesCache[track][currentPattern][step]) {
    const { pitchShift, distortion, delay, delayFilter, panner, gain } = extraEffectNodesCache[track][currentPattern][step];
    pitchShift.dispose();
    distortion.dispose();
    delay.dispose();
    delayFilter.dispose();
    panner.dispose();
    gain.dispose();
    delete extraEffectNodesCache[track][currentPattern][step];
  }

  const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
  stepEl.dataset.sampleLoaded = "false";
  stepEl.classList.remove("main-active", "selected");
  sequence[track][currentPattern][step] = false;

  const isMeasureStep = step % measures === 0 && stepEl.classList.contains("enabled");
  stepEl.classList.toggle("measure-highlight", isMeasureStep && !clickActive);
  stepEl.classList.toggle("measure-highlight-active", isMeasureStep && clickActive);

  if (selectedExtraStep === step) {
    selectedExtraStep = null;
    updateSoundSettingsUI();
  }
}  

// Modified toggleStep function (only the part for extra tracks)
function toggleStep(track, step, isVariation) {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
  if (!stepEl.classList.contains("enabled")) return;
  if (!sequence[track][currentPattern]) {
    sequence[track][currentPattern] = Array(32).fill(false);
  }

  if (!["extra", "extra2", "extra3", "extra4"].includes(track)) {
    selectedExtraStep = null;
    document.querySelectorAll(`.sequencer[data-track="extra"] .step, .sequencer[data-track="extra2"] .step, .sequencer[data-track="extra3"] .step, .sequencer[data-track="extra4"] .step`).forEach(s => s.classList.remove("selected"));

    const currentState = sequence[track][currentPattern][step];
    let newState;
    if (isVariation) {
      if (currentState === false) {
        newState = "variation"; // Right-click empty -> variation (light blue)
      } else if (currentState === "variation") {
        newState = false; // Right-click variation -> empty
      } else if (currentState === true) {
        newState = "both"; // Right-click main -> both
      } else if (currentState === "both") {
        newState = true; // Right-click both -> main
      }
    } else {
      if (currentState === false) {
        newState = true; // Left-click empty -> main (orange)
      } else if (currentState === true) {
        newState = false; // Left-click main -> empty
      } else if (currentState === "variation") {
        newState = true; // Left-click variation -> main
      } else if (currentState === "both") {
        newState = "variation"; // Left-click both -> variation
      }
    }
    sequence[track][currentPattern][step] = newState;
    stepEl.classList.toggle("main-active", newState === true || newState === "both");
    stepEl.classList.toggle("variation-active", newState === "variation" || newState === "both");
    const isMeasureStep = step % measures === 0 && stepEl.classList.contains("enabled");
    stepEl.classList.toggle("measure-highlight", isMeasureStep && !sequence[track][currentPattern][step] && !clickActive);
    stepEl.classList.toggle("measure-highlight-active", isMeasureStep && !sequence[track][currentPattern][step] && clickActive);
    if (isVariation && currentState !== newState) {
      refreshPannerConnections(track, true);
    }

    selectedSound = track;
    document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
    document.querySelector(`.pad[data-sound="${track}"]`).classList.add("selected");
    const sliders = [
      document.getElementById("panInput"),
      document.getElementById("volumeInput"),
      document.getElementById("distortionInput"),
      document.getElementById("delayMixInput"),
      document.getElementById("delayFeedbackInput"),
      document.getElementById("delayTimeInput"),
      document.getElementById("delayFilterInput"),
      document.getElementById("pitchMixInput")
    ];
    sliders.forEach(slider => {
      if (slider) {
        slider.classList.remove("main-mode", "variation-mode", "extra-mode");
        slider.classList.add(isVariation ? "variation-mode" : "main-mode");
      }
    });

    // Update only the selected track's steps
    const trackSteps = document.querySelectorAll(`.sequencer[data-track="${track}"] .step`);
    trackSteps.forEach((s, i) => {
      const stepState = sequence[track][currentPattern][i];
      s.classList.toggle("main-active", stepState === true || stepState === "both");
      s.classList.toggle("variation-active", stepState === "variation" || stepState === "both");
      const isExtraMeasureStep = i % measures === 0 && s.classList.contains("enabled");
      s.classList.toggle("measure-highlight", isExtraMeasureStep && !stepState && !clickActive);
      s.classList.toggle("measure-highlight-active", isExtraMeasureStep && !stepState && clickActive);
    });

    updateSoundSettingsUI();
  } else {
    // Existing code for extra tracks (unchanged)
    if (isCKeyPressed) {
      // Copy step settings
      copiedStepSettings = {
        isActive: sequence[track][currentPattern][step],
        sample: extraStepSamples[track][currentPattern][step],
        file: extraStepSamples[track][currentPattern][step] ? extraStepSamplers[track][currentPattern][step]?.buffer?._source?.file : null,
        panning: extraPanning[track][currentPattern][step] || 0,
        volume: extraVolumes[track][currentPattern][step] || 0.8,
        pitch: extraPitch[track][currentPattern][step] || 0,
        pitchMix: extraPitchMix[track][currentPattern][step] || 1,
        distortion: extraDistortionWet[track][currentPattern][step] || 0,
        delayMix: extraDelayMix[track][currentPattern][step] || 0,
        delayFeedback: extraDelayFeedback[track][currentPattern][step] || 0.3,
        delayTime: extraDelayTime[track][currentPattern][step] || 3,
        delayFilter: extraDelayFilterFreq[track][currentPattern][step] || 5000,
        mode: extraMonoPoly[track][currentPattern] || "step",
        subSequence: extraSubSequences[track][currentPattern][step]?.slice() || Array(32).fill(false),
        substepCount: extraSubstepCounts[track][currentPattern][step] || 1
      };
      console.log(`Copied settings for ${track} track, step ${step}`);
      return;
    }
    // Paste step settings
    if (isVKeyPressed && copiedStepSettings) {
      sequence[track][currentPattern][step] = copiedStepSettings.isActive;
      extraStepSamples[track][currentPattern][step] = copiedStepSettings.sample;
      extraPanning[track][currentPattern][step] = copiedStepSettings.panning;
      extraVolumes[track][currentPattern][step] = copiedStepSettings.volume;
      extraPitch[track][currentPattern][step] = copiedStepSettings.pitch;
      extraPitchMix[track][currentPattern][step] = copiedStepSettings.pitchMix;
      extraDistortionWet[track][currentPattern][step] = copiedStepSettings.distortion;
      extraDelayMix[track][currentPattern][step] = copiedStepSettings.delayMix;
      extraDelayFeedback[track][currentPattern][step] = copiedStepSettings.delayFeedback;
      extraDelayTime[track][currentPattern][step] = copiedStepSettings.delayTime;
      extraDelayFilterFreq[track][currentPattern][step] = copiedStepSettings.delayFilter;
      extraMonoPoly[track][currentPattern] = copiedStepSettings.mode;
      extraSubSequences[track][currentPattern][step] = copiedStepSettings.subSequence.slice();
      extraSubstepCounts[track][currentPattern][step] = copiedStepSettings.substepCount;

      if (copiedStepSettings.sample && copiedStepSettings.file) {
        try {
          const url = URL.createObjectURL(copiedStepSettings.file);
          extraStepSamplers[track][currentPattern][step]?.dispose();
          extraStepSamplers[track][currentPattern][step] = new Tone.Player({
            url: url,
            onload: () => {
              console.log(`Pasted sample loaded for ${track} track, step ${step}`);
              URL.revokeObjectURL(url);
              updateTrackUI();
            },
            onerror: (error) => {
              console.error(`Failed to load pasted sample for ${track} track, step ${step}:`, error);
              extraStepSamples[track][currentPattern][step] = null;
              extraStepSamplers[track][currentPattern][step] = null;
              updateTrackUI();
            }
          }).toDestination();
        } catch (error) {
          console.error(`Error creating Tone.Player for pasted step ${step}:`, error);
          extraStepSamples[track][currentPattern][step] = null;
          extraStepSamplers[track][currentPattern][step] = null;
          updateTrackUI();
        }
      } else {
        extraStepSamplers[track][currentPattern][step] = null;
      }
      updateTrackUI();
      console.log(`Pasted settings for ${track} track, step ${step}`);
      return;
} else if (isVariation) {
      const fileInput = document.querySelector(`.sample-input[data-sound="${track}"]`);
      fileInput.dataset.step = step;
      fileInput.click();
    } else if (isDKeyPressed && extraStepSamples[track][currentPattern][step]) {
      removeExtraStepSample(track, step);
    } else {
// Update the selected track's pad to turn green
      document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
      document.querySelector(`.pad[data-sound="${track}"]`).classList.add("selected");
      const isActive = sequence[track][currentPattern][step];
      const isSelected = selectedExtraStep === step;

      // Clear previous selections for ALL extra tracks
      document.querySelectorAll(`.sequencer[data-track="extra"] .step, .sequencer[data-track="extra2"] .step, .sequencer[data-track="extra3"] .step, .sequencer[data-track="extra4"] .step`).forEach(s => {
        s.classList.remove("selected");
      });
      selectedExtraStep = null;

      if (isActive && isSelected) {
        sequence[track][currentPattern][step] = false;
        stepEl.classList.remove("main-active", "selected");
        if (activeExtraPlayers[step]) {
          activeExtraPlayers[step].forEach(player => player.stop());
          activeExtraPlayers[step] = [];
        }
      } else if (isActive && !isSelected) {
        selectedExtraStep = step;
        stepEl.classList.add("selected");
      } else {
        sequence[track][currentPattern][step] = true;
        stepEl.classList.add("main-active", "selected");
        selectedExtraStep = step;
        if (!activeExtraPlayers[step]) activeExtraPlayers[step] = [];
      }
      stepEl.dataset.sampleLoaded = extraStepSamples[track][currentPattern][step] ? "true" : "false";
      initializeExtraSubSequence(track, currentPattern, step);
      updateSubSteps(track);
      updateSoundSettingsUI();

      const isMeasureStep = step % measures === 0 && stepEl.classList.contains("enabled");
      stepEl.classList.toggle("measure-highlight", isMeasureStep && !sequence[track][currentPattern][step] && !clickActive);
      stepEl.classList.toggle("measure-highlight-active", isMeasureStep && !sequence[track][currentPattern][step] && clickActive);

      const anyExtraActive = sequence[track][currentPattern].some(state => state);
      const extraToggle = document.querySelector(".extra-toggle");
      extraToggle.style.display = anyExtraActive ? "block" : "none";
      extraToggle.classList.toggle("active", anyExtraActive);
      extraToggle.style.backgroundColor = anyExtraActive ? "#909B20" : "#909B20";
      const monoPolyToggle = document.querySelector(".mono-poly-toggle");
      monoPolyToggle.style.display = "none";

      selectedSound = track;
      document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
      document.querySelector(`.pad[data-sound="${track}"]`).classList.add("selected");

      const sliders = [
        document.getElementById("panInput"),
        document.getElementById("volumeInput"),
        document.getElementById("distortionInput"),
        document.getElementById("delayMixInput"),
        document.getElementById("delayFeedbackInput"),
        document.getElementById("delayTimeInput"),
        document.getElementById("delayFilterInput"),
        document.getElementById("pitchMixInput")
      ];
      sliders.forEach(slider => {
        if (slider) {
          slider.classList.remove("main-mode", "variation-mode");
          slider.classList.add("extra-mode");
        }
      });

      updateSoundSettingsUI();
    }
  }
}

document.querySelectorAll(".pad").forEach(pad => {
  pad.addEventListener("click", async () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const sound = pad.dataset.sound;
    const note = pad.dataset.note;
    
    if (sound !== "extra") {
      selectedExtraStep = null;
      document.querySelectorAll(`.sequencer[data-track="extra"] .step, .sequencer[data-track="extra2"] .step, .sequencer[data-track="extra3"] .step, .sequencer[data-track="extra4"] .step`).forEach(s => s.classList.remove("selected"));
    }

    selectedSound = sound;
    if (["extra", "extra2", "extra3", "extra4"].includes(sound)) {
  const toggle = document.querySelector(`.extra-mode-toggle[data-sound="${sound}"]`);
  if (toggle) {
    const mode = extraMonoPoly[sound][currentPattern] || "step";
    toggle.dataset.mode = mode;
    toggle.textContent = mode.toUpperCase();
  }
}
    
    const extraSteps = document.querySelectorAll(`.sequencer[data-track="extra"] .step`);
    extraSteps.forEach((s, i) => {
      s.classList.toggle("main-active", sequence["extra"][currentPattern][i]);
      const isExtraMeasureStep = i % measures === 0 && s.classList.contains("enabled");
      s.classList.toggle("measure-highlight", isExtraMeasureStep && !sequence["extra"][currentPattern][i] && !clickActive);
      s.classList.toggle("measure-highlight-active", isExtraMeasureStep && !sequence["extra"][currentPattern][i] && clickActive);
      s.classList.remove("selected"); 
      s.setAttribute("data-sample-loaded", extraStepSamples["extra"][currentPattern][i] ? "true" : "false");
    });

    const anyExtraActive = sequence["extra"][currentPattern].some(state => state);
    const extraToggle = document.querySelector(".extra-toggle");
    extraToggle.style.display = anyExtraActive ? "block" : "none";
    extraToggle.classList.toggle("active", anyExtraActive);

    document.querySelector(".secondary-name").value = soundNames[note] || sound;
    document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
    pad.classList.add("selected");
    document.querySelectorAll(".sequencer .step").forEach(step => step.classList.remove("track-selected"));
    document.querySelectorAll(`.sequencer[data-track="${sound}"] .step`).forEach(step => step.classList.add("track-selected"));
    if (!mainSubSequences[sound][currentPattern]?.some(step => step) && mainSubstepCounts[sound][currentPattern] === 1) {
      mainSubSequences[sound][currentPattern] = Array(8).fill(false);
      mainSubSequences[sound][currentPattern][0] = true;
    }
    if (!variationSubSequences[sound][currentPattern]?.some(step => step) && variationSubstepCounts[sound][currentPattern] === 1) {
      variationSubSequences[sound][currentPattern] = Array(8).fill(false);
      variationSubSequences[sound][currentPattern][0] = true;
    }
    updateSubSteps(sound);
    updateSoundSettingsUI();
    refreshPannerConnections(sound, isVariationSubsequencer);
    if (sound !== "extra" && !isPlaying) {
      if (loadedSamples[note] && samplers[sound].loaded) {
        const player = new Tone.Player({
          url: loadedSamples[note],
          autostart: false,
          onload: () => {
            player.start(Tone.now() + 0.01); 
            player.onended = () => player.dispose();
          },
          onerror: (error) => console.error(`Failed to play clean sample for ${sound}: ${error}`)
        }).toDestination();
      }
    }
    pad.classList.add("active");
    setTimeout(() => pad.classList.remove("active"), 100);
  });
});

function updateTrackSteps(track, stepCount) {
  const trackDiv = sequencerDiv.querySelector(`[data-track="${track}"]`);
  const steps = trackDiv.querySelectorAll(".step");
  steps.forEach((step, i) => {
    const isEnabled = i < stepCount;
    step.classList.toggle("enabled", isEnabled);
    if (sequence[track][currentPattern]) {
      step.classList.toggle("main-active", (sequence[track][currentPattern][i] === true || sequence[track][currentPattern][i] === "both") && isEnabled);
      step.classList.toggle("variation-active", (sequence[track][currentPattern][i] === "variation" || sequence[track][currentPattern][i] === "both") && isEnabled);
    } else {
      step.classList.remove("main-active", "variation-active");
    }
    const isMeasureStep = i % measures === 0 && isEnabled;
    step.classList.toggle("measure-highlight", isMeasureStep && !sequence[track][currentPattern]?.[i] && !clickActive);
    step.classList.toggle("measure-highlight-active", isMeasureStep && !sequence[track][currentPattern]?.[i] && clickActive);
  });
}

// Modified toggleSubStep to handle extra track subsequencer
function updateSubSteps(track) {
  if (!track || !tracks.includes(track)) {
    console.error(`Invalid track for updateSubSteps: ${track}`);
    return;
  }
  const isVariation = isVariationSubsequencer;
  const pattern = currentPattern;
  let subSequence, substepCount;

  if (["extra", "extra2", "extra3", "extra4"].includes(track) && selectedExtraStep !== null) {
    initializeExtraSubSequence(track, pattern, selectedExtraStep);
    subSequence = extraSubSequences[track][pattern][selectedExtraStep];
    substepCount = extraSubstepCounts[track][pattern][selectedExtraStep];
  } else {
    subSequence = isVariation ? variationSubSequences[track][pattern] : mainSubSequences[track][pattern];
    substepCount = isVariation ? variationSubstepCounts[track][pattern] : mainSubstepCounts[track][pattern];
  }
  
  if (!subSequence) {
    const newSequence = Array(32).fill(false);
    newSequence[0] = true;
    if (["extra", "extra2", "extra3", "extra4"].includes(track) && selectedExtraStep !== null) {
      extraSubSequences[track][pattern][selectedExtraStep] = newSequence;
      extraSubstepCounts[track][pattern][selectedExtraStep] = 1;
    } else if (isVariation) {
      variationSubSequences[track][pattern] = newSequence;
      variationSubstepCounts[track][pattern] = 1;
    } else {
      mainSubSequences[track][pattern] = newSequence;
      mainSubstepCounts[track][pattern] = 1;
    }
    subSequence = newSequence;
    substepCount = 1;
  }
  
  const secondaryTrackDiv = document.querySelector(`[data-track="secondary"]`);
  const steps = secondaryTrackDiv.querySelectorAll(".secondary-step");
  
  steps.forEach((step, i) => {
    if (!step) return;
    const isEnabled = i < substepCount;
    step.classList.toggle("enabled", isEnabled);
    step.classList.remove("active", "main-active", "variation-active", "extra-active");
    
    if (subSequence?.[i] && isEnabled) {
      if (["extra", "extra2", "extra3", "extra4"].includes(track)) {
        step.classList.add("active", "extra-active");
      } else if (isVariation) {
        step.classList.add("active", "variation-active");
      } else {
        step.classList.add("active", "main-active");
      }
    }
  });
  
  document.getElementById("substepsInput").value = substepCount;
}
  
  function toggleSubStep(step) {
  if (!audioStarted || !selectedSound) {
    alert("Please click 'Start Audio' and select a sound first!");
    return;
  }
  if (!tracks.includes(selectedSound)) {
    console.error(`Invalid track for toggleSubStep: ${selectedSound}`);
    return;
  }
  const pattern = currentPattern;
  let subSequence, substepCount;

  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    initializeExtraSubSequence(selectedSound, pattern, selectedExtraStep);
    subSequence = extraSubSequences[selectedSound][pattern][selectedExtraStep];
    substepCount = extraSubstepCounts[selectedSound][pattern][selectedExtraStep];
  } else {
    subSequence = isVariationSubsequencer ? variationSubSequences[selectedSound][pattern] : mainSubSequences[selectedSound][pattern];
    substepCount = isVariationSubsequencer ? variationSubstepCounts[selectedSound][pattern] : mainSubstepCounts[selectedSound][pattern];
  }

  if (!subSequence || step >= substepCount) return;

  subSequence[step] = !subSequence[step];

  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraSubSequences[selectedSound][pattern][selectedExtraStep] = subSequence;
  } else if (isVariationSubsequencer) {
    variationSubSequences[selectedSound][pattern] = subSequence;
  } else {
    mainSubSequences[selectedSound][pattern] = subSequence;
  }

  updateSubSteps(selectedSound);
}
  
function updateSoundSettingsUI() {
  const elements = {
    panInput: document.getElementById("panInput"),
    volumeInput: document.getElementById("volumeInput"),
    distortionInput: document.getElementById("distortionInput"),
    delayMixInput: document.getElementById("delayMixInput"),
    delayFeedbackInput: document.getElementById("delayFeedbackInput"),
    delayTimeInput: document.getElementById("delayTimeInput"),
    delayFilterInput: document.getElementById("delayFilterInput"),
    pitchInput: document.getElementById("pitchInput"),
    pitchMixInput: document.getElementById("pitchMixInput"),
    monoPolyToggle: document.querySelector(".mono-poly-toggle"),
    extraModeToggle: document.querySelector(".extra-mode-toggle"), // This line is fine
    secondaryName: document.querySelector(".secondary-name")
  };

  const subsequencerTogglesDiv = document.querySelector(".subsequencer-toggles");
  const extraToggle = document.querySelector(".extra-toggle");

  if (!selectedSound || Object.values(elements).some(el => !el)) {
    Object.values(elements).forEach(el => {
      if (el && el !== elements.secondaryName && el !== elements.monoPolyToggle && el !== elements.extraModeToggle) {
        el.value = el.id.includes("delayTime") ? 3 : el.id.includes("delayFilter") ? 5000 : el.id.includes("pitch") && !el.id.includes("pitchMix") ? 0 : el.id.includes("volume") ? 0.8 : el.id.includes("delayFeedback") ? 0.3 : 0;
        el.disabled = true;
      }
    });
    if (elements.monoPolyToggle) {
      elements.monoPolyToggle.dataset.mode = "mono";
      elements.monoPolyToggle.textContent = "MONO";
      elements.monoPolyToggle.classList.remove("poly", "full");
      elements.monoPolyToggle.style.display = "none";
    }
    if (elements.extraModeToggle) {
      elements.extraModeToggle.dataset.mode = "step";
      elements.extraModeToggle.textContent = "STEP";
      elements.extraModeToggle.style.display = "none";
    }
    if (elements.secondaryName) {
      elements.secondaryName.value = "None";
    }
    subsequencerTogglesDiv.style.display = "flex";
    extraToggle.style.display = "none";
    return;
  }

  const isExtraTrack = ["extra", "extra2", "extra3", "extra4"].includes(selectedSound);

// Set visibility of toggles based on track type
subsequencerTogglesDiv.style.display = isExtraTrack ? "none" : "flex";
extraToggle.style.display = isExtraTrack ? "block" : "none";
elements.monoPolyToggle.style.display = isExtraTrack ? "none" : "flex";
elements.monoPolyToggle.disabled = isExtraTrack;
document.querySelectorAll(".extra-mode-toggle").forEach(toggle => {
  toggle.style.display = "flex"; // Always show extra mode toggles
  if (toggle.dataset.sound === selectedSound) {
    toggle.dataset.mode = extraMonoPoly[selectedSound][currentPattern] || "step";
    toggle.textContent = toggle.dataset.mode.toUpperCase();
  }
});

  // Update toggle colors for subsequencer toggles
  subsequencerTogglesDiv.querySelectorAll(".subsequencer-toggle").forEach(toggle => {
    toggle.classList.toggle("main-active", toggle.dataset.mode === "main" && !isVariationSubsequencer && !isExtraTrack);
    toggle.classList.toggle("variation-active", toggle.dataset.mode === "variation" && isVariationSubsequencer && !isExtraTrack);
  });

  if (!isVariationSubsequencer) {
    mainPanning[selectedSound][currentPattern] = mainPanning[selectedSound][currentPattern] ?? 0;
    mainVolumes[selectedSound][currentPattern] = mainVolumes[selectedSound][currentPattern] ?? 0.8;
    mainDistortionWet[selectedSound][currentPattern] = mainDistortionWet[selectedSound][currentPattern] ?? 0;
    mainDelayMix[selectedSound][currentPattern] = mainDelayMix[selectedSound][currentPattern] ?? 0;
    mainDelayFeedback[selectedSound][currentPattern] = mainDelayFeedback[selectedSound][currentPattern] ?? 0.3;
    mainDelayTime[selectedSound][currentPattern] = mainDelayTime[selectedSound][currentPattern] ?? 3;
    mainDelayFilterFreq[selectedSound][currentPattern] = mainDelayFilterFreq[selectedSound][currentPattern] ?? 5000;
    mainPitch[selectedSound][currentPattern] = mainPitch[selectedSound][currentPattern] ?? 0;
    mainPitchMix[selectedSound][currentPattern] = mainPitchMix[selectedSound][currentPattern] ?? 0;
    mainMonoPoly[selectedSound][currentPattern] = mainMonoPoly[selectedSound][currentPattern] ?? "mono";
    if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound)) {
      extraMonoPoly[selectedSound][currentPattern] = extraMonoPoly[selectedSound][currentPattern] ?? "step";
    }
  } else {
    variationPanning[selectedSound][currentPattern] = variationPanning[selectedSound][currentPattern] ?? 0;
    variationVolumes[selectedSound][currentPattern] = variationVolumes[selectedSound][currentPattern] ?? 0.8;
    variationDistortionWet[selectedSound][currentPattern] = variationDistortionWet[selectedSound][currentPattern] ?? 0;
    variationDelayMix[selectedSound][currentPattern] = variationDelayMix[selectedSound][currentPattern] ?? 0;
    variationDelayFeedback[selectedSound][currentPattern] = variationDelayFeedback[selectedSound][currentPattern] ?? 0.3;
    variationDelayTime[selectedSound][currentPattern] = variationDelayTime[selectedSound][currentPattern] ?? 3;
    variationDelayFilterFreq[selectedSound][currentPattern] = variationDelayFilterFreq[selectedSound][currentPattern] ?? 5000;
    variationPitch[selectedSound][currentPattern] = variationPitch[selectedSound][currentPattern] ?? 0;
    variationPitchMix[selectedSound][currentPattern] = variationPitchMix[selectedSound][currentPattern] ?? 0;
    variationMonoPoly[selectedSound][currentPattern] = variationMonoPoly[selectedSound][currentPattern] ?? "mono";
  }

  const panValue = isVariationSubsequencer ? variationPanning[selectedSound][currentPattern] : mainPanning[selectedSound][currentPattern];
  const volumeValue = isVariationSubsequencer ? variationVolumes[selectedSound][currentPattern] : mainVolumes[selectedSound][currentPattern];
  const distortionValue = isVariationSubsequencer ? variationDistortionWet[selectedSound][currentPattern] : mainDistortionWet[selectedSound][currentPattern];
  const delayMixValue = isVariationSubsequencer ? variationDelayMix[selectedSound][currentPattern] : mainDelayMix[selectedSound][currentPattern];
  const delayFeedbackValue = isVariationSubsequencer ? variationDelayFeedback[selectedSound][currentPattern] : mainDelayFeedback[selectedSound][currentPattern];
  const delayTimeValue = isVariationSubsequencer ? variationDelayTime[selectedSound][currentPattern] : mainDelayTime[selectedSound][currentPattern];
  const delayFilterValue = isVariationSubsequencer ? variationDelayFilterFreq[selectedSound][currentPattern] : mainDelayFilterFreq[selectedSound][currentPattern];
  const pitchValue = isVariationSubsequencer ? variationPitch[selectedSound][currentPattern] : mainPitch[selectedSound][currentPattern];
  const pitchMixValue = isVariationSubsequencer ? variationPitchMix[selectedSound][currentPattern] : mainPitchMix[selectedSound][currentPattern];
  const monoPolyMode = selectedSound === "extra" ? (extraMonoPoly[selectedSound][currentPattern] || "step") : (isVariationSubsequencer ? variationMonoPoly[selectedSound][currentPattern] : mainMonoPoly[selectedSound][currentPattern]) || "mono";
  const extraMode = extraMonoPoly[selectedSound][currentPattern] || "step";

  elements.panInput.disabled = false;
  elements.volumeInput.disabled = false;
  elements.distortionInput.disabled = false;
  elements.delayMixInput.disabled = false;
  elements.delayFeedbackInput.disabled = false;
  elements.delayTimeInput.disabled = false;
  elements.delayFilterInput.disabled = false;
  elements.pitchInput.disabled = false;
  elements.pitchMixInput.disabled = false;

  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    elements.panInput.value = extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0;
    elements.volumeInput.value = extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8;
    elements.pitchInput.value = extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0;
    elements.pitchMixInput.value = extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1;
    elements.distortionInput.value = extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0;
    elements.delayMixInput.value = extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0;
    elements.delayFeedbackInput.value = extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3;
    elements.delayTimeInput.value = extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3;
    elements.delayFilterInput.value = extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000;
  } else {
    elements.panInput.value = panValue;
    elements.volumeInput.value = volumeValue;
    elements.pitchInput.value = pitchValue;
    elements.pitchMixInput.value = pitchMixValue;
    elements.distortionInput.value = distortionValue;
    elements.delayMixInput.value = delayMixValue;
    elements.delayFeedbackInput.value = delayFeedbackValue;
    elements.delayTimeInput.value = delayTimeValue;
    elements.delayFilterInput.value = delayFilterValue;
  }
  
  if (elements.monoPolyToggle) {
    elements.monoPolyToggle.dataset.mode = monoPolyMode;
    elements.monoPolyToggle.textContent = typeof monoPolyMode === "string" ? monoPolyMode.toUpperCase() : "MONO";
    elements.monoPolyToggle.classList.toggle("poly", monoPolyMode === "poly");
    elements.monoPolyToggle.classList.toggle("full", monoPolyMode === "full");
  }
  if (elements.extraModeToggle) {
    elements.extraModeToggle.dataset.mode = extraMode;
    elements.extraModeToggle.textContent = typeof extraMode === "string" ? extraMode.toUpperCase() : "STEP";
  }

  const panner = isVariationSubsequencer ? variationPanners[selectedSound] : mainPanners[selectedSound];
  const gain = isVariationSubsequencer ? variationGains[selectedSound] : mainGains[selectedSound];
  const distortion = isVariationSubsequencer ? variationDistortions[selectedSound] : mainDistortions[selectedSound];
  const delay = isVariationSubsequencer ? variationDelays[selectedSound] : mainDelays[selectedSound];
  const delayGain = isVariationSubsequencer ? variationDelayGains[selectedSound] : mainDelayGains[selectedSound];
  const filter = isVariationSubsequencer ? variationDelayFilters[selectedSound] : mainDelayFilters[selectedSound];
  const pitchShift = isVariationSubsequencer ? variationPitchShifters[selectedSound] : mainPitchShifters[selectedSound];

  panner.pan.setValueAtTime(panValue, Tone.now());
  gain.gain.setValueAtTime(volumeValue, Tone.now());
  distortion.wet.setValueAtTime(distortionValue, Tone.now());
  delay.wet.setValueAtTime(delayMixValue, Tone.now());
  delayGain.gain.setValueAtTime(delayMixValue * 0.8, Tone.now());
  delay.feedback.setValueAtTime(delayFeedbackValue, Tone.now());
  delay.delayTime.setValueAtTime(subdivisions[delayTimeValue]?.time || "4n", Tone.now());
  filter.frequency.setValueAtTime(delayFilterValue, Tone.now());
  pitchShift.pitch = pitchValue;
  pitchShift.wet.setValueAtTime(pitchMixValue, Tone.now());

  const sliders = [
    elements.panInput,
    elements.volumeInput,
    elements.distortionInput,
    elements.delayMixInput,
    elements.delayFeedbackInput,
    elements.delayTimeInput,
    elements.delayFilterInput,
    elements.pitchMixInput
  ];
  sliders.forEach(slider => {
    if (slider) {
      slider.classList.remove("main-mode", "variation-mode", "extra-mode");
      if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound)) {
        slider.classList.add("extra-mode");
      } else {
        slider.classList.add(isVariationSubsequencer ? "variation-mode" : "main-mode");
      }
    }
  });

// Modified part of updateSoundSettingsUI function
if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null && extraStepSamples[selectedSound][currentPattern][selectedExtraStep]) {
    const sampleUrl = extraStepSamples[selectedSound][currentPattern][selectedExtraStep];
    const fileName = sampleUrl.split('/').pop().split('#')[0].split('?')[0];
    const decodedFileName = decodeURIComponent(fileName);
    const cleanFileName = decodedFileName.replace(/\.[^/.]+$/, "");
    elements.secondaryName.value = cleanFileName;
} else if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound)) {
    elements.secondaryName.value = "No Sample";
} else {
    const note = notes[tracks.indexOf(selectedSound)];
    elements.secondaryName.value = soundNames[note] || selectedSound;
}
}

function updateClickUI() {
  const clickPad = document.querySelector(".click-pad");
  clickPad.classList.toggle("active", clickActive);
  tracks.forEach(track => updateTrackSteps(track, trackStepCounts[track]));
}

document.querySelectorAll(".pad").forEach(pad => {
  pad.addEventListener("click", async () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const sound = pad.dataset.sound;
    const note = pad.dataset.note;
    
    if (sound !== "extra") {
      selectedExtraStep = null;
      document.querySelectorAll(`.sequencer[data-track="extra"] .step, .sequencer[data-track="extra2"] .step, .sequencer[data-track="extra3"] .step, .sequencer[data-track="extra4"] .step`).forEach(s => s.classList.remove("selected"));
    }

    selectedSound = sound;
    
    const extraSteps = document.querySelectorAll(`.sequencer[data-track="extra"] .step`);
    extraSteps.forEach((s, i) => {
      s.classList.toggle("main-active", sequence["extra"][currentPattern][i]);
      const isExtraMeasureStep = i % measures === 0 && s.classList.contains("enabled");
      s.classList.toggle("measure-highlight", isExtraMeasureStep && !sequence["extra"][currentPattern][i] && !clickActive);
      s.classList.toggle("measure-highlight-active", isExtraMeasureStep && !sequence["extra"][currentPattern][i] && clickActive);
      s.classList.remove("selected"); 
      s.setAttribute("data-sample-loaded", extraStepSamples["extra"][currentPattern][i] ? "true" : "false");
    });

    const anyExtraActive = sequence["extra"][currentPattern].some(state => state);
    const extraToggle = document.querySelector(".extra-toggle");
    extraToggle.style.display = anyExtraActive ? "block" : "none";
    extraToggle.classList.toggle("active", anyExtraActive);

    document.querySelector(".secondary-name").value = soundNames[note] || sound;
    document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
    pad.classList.add("selected");
    document.querySelectorAll(".sequencer .step").forEach(step => step.classList.remove("track-selected"));
    document.querySelectorAll(`.sequencer[data-track="${sound}"] .step`).forEach(step => step.classList.add("track-selected"));
    if (!mainSubSequences[sound][currentPattern]?.some(step => step) && mainSubstepCounts[sound][currentPattern] === 1) {
      mainSubSequences[sound][currentPattern] = Array(8).fill(false);
      mainSubSequences[sound][currentPattern][0] = true;
    }
    if (!variationSubSequences[sound][currentPattern]?.some(step => step) && variationSubstepCounts[sound][currentPattern] === 1) {
      variationSubSequences[sound][currentPattern] = Array(8).fill(false);
      variationSubSequences[sound][currentPattern][0] = true;
    }
    updateSubSteps(sound);
    updateSoundSettingsUI();
    refreshPannerConnections(sound, isVariationSubsequencer);
    if (sound !== "extra" && !isPlaying) {
      if (loadedSamples[note] && samplers[sound].loaded) {
        const player = new Tone.Player({
          url: loadedSamples[note],
          autostart: false,
          onload: () => {
            player.start(Tone.now() + 0.01); 
            player.onended = () => player.dispose();
          },
          onerror: (error) => console.error(`Failed to play clean sample for ${sound}: ${error}`)
        }).toDestination();
      }
    }
    pad.classList.add("active");
    setTimeout(() => pad.classList.remove("active"), 100);
  });
});

function updatePatternDisplay() {
  const patternDisplay = document.getElementById("patternDisplay");
  const sequencerPatternDisplay = document.getElementById("sequencerPatternDisplay");
  const selectedPatternBox = document.querySelector(`.pattern-box[data-pattern="${currentPattern}"]`);
  const baseColor = selectedPatternBox ? getComputedStyle(selectedPatternBox).backgroundColor : "#808080";

  patternDisplay.textContent = currentPattern;
  patternDisplay.style.backgroundColor = baseColor;

  if (sequencerPatternDisplay) {
    sequencerPatternDisplay.textContent = currentPattern;
    sequencerPatternDisplay.style.backgroundColor = baseColor;
  }
}

function handleSampleDrop(note, sound, file) {
  if (!file || !file.type.startsWith("audio/")) {
    alert(`Skipped ${file ? file.name : "unknown"}: Not an audio file`);
    return;
  }
  const url = URL.createObjectURL(file);
  loadedSamples[note] = url;
  soundNames[note] = file.name;
  if (samplers[sound]) samplers[sound].dispose();
  samplers[sound] = new Tone.Sampler({
    urls: { [note]: url },
    onload: () => {
      refreshPannerConnections(sound, isVariationSubsequencer);
      updateTrackUI();
      selectedSound = sound;
      document.querySelectorAll(".pad").forEach(p => p.classList.remove("selected"));
      const pad = document.querySelector(`.pad[data-sound="${sound}"]`);
      if (pad) pad.classList.add("selected");
      document.querySelector(".secondary-name").value = soundNames[note] || sound;
      updateSubSteps(sound);
      updateSoundSettingsUI();
      refreshPannerConnections(sound, isVariationSubsequencer);
    },
    onerror: (error) => {
      console.error(`Failed to add sample ${file.name} for ${note}: ${error}`);
      loadedSamples[note] = null;
      updateTrackUI();
    }
  }).toDestination();
}

function handleClickSampleDrop(file) {
  if (!file || !file.type.startsWith("audio/")) {
    alert(`Skipped ${file ? file.name : "unknown"}: Not an audio file`);
    return;
  }
  const url = URL.createObjectURL(file);
  clickSample = url;
  if (clickSampler) clickSampler.dispose();
  clickSampler = new Tone.Sampler({
    urls: { C3: url },
    onerror: (error) => {
      console.error(`Click sampler failed to load: ${error}`);
      clickSample = null;
    }
  }).toDestination();
}

document.querySelectorAll(".pad").forEach(pad => {
  pad.addEventListener("dragover", (e) => {
    e.preventDefault();
    pad.classList.add("dragover");
  });
  pad.addEventListener("dragleave", () => pad.classList.remove("dragover"));
  pad.addEventListener("drop", async (e) => {
    e.preventDefault();
    pad.classList.remove("dragover");
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const file = e.dataTransfer.files[0];
    const note = pad.dataset.note;
    const sound = pad.dataset.sound;
    handleSampleDrop(note, sound, file);
  });
  pad.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const sound = pad.dataset.sound;
    const fileInput = document.querySelector(`.sample-input[data-sound="${sound}"]`);
    if (fileInput) fileInput.click();
  });
});

document.querySelectorAll(".name-input").forEach(input => {
  input.addEventListener("dragover", (e) => {
    e.preventDefault();
    input.classList.add("dragover");
  });
  input.addEventListener("dragleave", () => input.classList.remove("dragover"));
  input.addEventListener("drop", async (e) => {
    e.preventDefault();
    input.classList.remove("dragover");
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const file = e.dataTransfer.files[0];
    const sound = input.dataset.sound;
    const note = tracks.reduce((note, track, i) => track === sound ? notes[i] : note, null);
    handleSampleDrop(note, sound, file);
  });
  input.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const sound = input.dataset.sound;
    const fileInput = document.querySelector(`.sample-input[data-sound="${sound}"]`);
    if (fileInput) fileInput.click();
  });
});

document.querySelectorAll(".sample-input").forEach(input => {
  input.addEventListener("change", (e) => {
    const file = e.target.files[0];
    const sound = input.dataset.sound;
    const note = input.dataset.note;
    if (file) {
      handleSampleDrop(note, sound, file);
      input.value = "";
    }
  });
});

const clickPad = document.querySelector(".click-pad");
clickPad.addEventListener("click", () => {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  clickActive = !clickActive;
  updateClickUI();
});
clickPad.addEventListener("dragover", (e) => {
  e.preventDefault();
  clickPad.classList.add("dragover");
});
clickPad.addEventListener("dragleave", () => clickPad.classList.remove("dragover"));
clickPad.addEventListener("drop", async (e) => {
  e.preventDefault();
  clickPad.classList.remove("dragover");
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const file = e.dataTransfer.files[0];
  handleClickSampleDrop(file);
});
clickPad.addEventListener("contextmenu", (e) => {
  e.preventDefault();
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  document.getElementById("clickSampleInput").click();
});

const clickMeasuresInput = document.getElementById("clickMeasuresInput");
clickMeasuresInput.addEventListener("dragover", (e) => {
  e.preventDefault();
  clickMeasuresInput.classList.add("dragover");
});
clickMeasuresInput.addEventListener("dragleave", () => clickMeasuresInput.classList.remove("dragover"));
clickMeasuresInput.addEventListener("drop", async (e) => {
  e.preventDefault();
  clickMeasuresInput.classList.remove("dragover");
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const file = e.dataTransfer.files[0];
  handleClickSampleDrop(file);
});

document.getElementById("clickSampleInput").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) {
    handleClickSampleDrop(file);
    e.target.value = "";
  }
});

const updateMeasures = () => {
  let newMeasures = parseInt(clickMeasuresInput.value, 10);
  if (isNaN(newMeasures)) {
    clickMeasuresInput.value = patternMeasures[currentPattern] || 4;
    measures = patternMeasures[currentPattern] || 4;
    updateClickUI();
    return;
  }
  if (newMeasures < 1) newMeasures = 1;
  if (newMeasures > 32) newMeasures = 32;
  measures = newMeasures;
  patternMeasures[currentPattern] = newMeasures;
  clickMeasuresInput.value = measures;
  updateClickUI();
};
    
clickMeasuresInput.addEventListener("change", updateMeasures);
clickMeasuresInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    clickMeasuresInput.blur();
    updateMeasures();
  }
});

function updateTrackUI() {
  document.querySelectorAll(".track-row").forEach(row => {
    const pad = row.querySelector(".pad");
    const nameInput = row.querySelector(".name-input");
    const note = pad.dataset.note;
    const sound = pad.dataset.sound;
    pad.classList.toggle("loaded", !!loadedSamples[note]);
    nameInput.value = soundNames[note];
    if (selectedSound === sound) {
      document.querySelector(".secondary-name").value = soundNames[note];
    }
  });
}

document.querySelectorAll(".lock-pad").forEach(pad => {
  pad.addEventListener("click", () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const track = pad.dataset.sound;
    trackStepLocks[track] = !trackStepLocks[track];
    pad.classList.toggle("locked", trackStepLocks[track]);
  });
});

document.querySelectorAll(".solo-pad").forEach(pad => {
  pad.addEventListener("click", () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const track = pad.dataset.sound;
    trackSoloStates[track] = !trackSoloStates[track];
    pad.classList.toggle("soloed", trackSoloStates[track]);
  });
});

document.querySelectorAll(".mute-pad").forEach(pad => {
  pad.addEventListener("click", () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    const track = pad.dataset.sound;
    trackMuteStates[track] = !trackMuteStates[track];
    pad.classList.toggle("muted", trackMuteStates[track]);
  });
});

document.querySelectorAll(".extra-mode-toggle").forEach(toggle => {
  toggle.style.display = "flex"; // Always show STEP/NEXT/FULL buttons
});    
    
const substepsInput = document.getElementById("substepsInput");

// Modified updateSubsteps to handle main and variation substeps independently
const updateSubsteps = () => {
  if (!audioStarted || !selectedSound) {
    alert("Please click 'Start Audio' and select a sound first!");
    return;
  }
  let count = parseInt(substepsInput.value, 10);
  if (isNaN(count)) {
    substepsInput.value = 1;
    if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
      extraSubstepCounts[selectedSound][currentPattern][selectedExtraStep] = 1;
    } else {
      if (isVariationSubsequencer) {
        variationSubstepCounts[selectedSound][currentPattern] = 1;
      } else {
        mainSubstepCounts[selectedSound][currentPattern] = 1;
      }
    }
    updateSubSteps(selectedSound);
    return;
  }
  if (count < 1) count = 1;
  if (count > 32) count = 32;

  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraSubstepCounts[selectedSound][currentPattern][selectedExtraStep] = count;
    if (!extraSubSequences[selectedSound][currentPattern]) {
      extraSubSequences[selectedSound][currentPattern] = {};
    }
    if (!extraSubSequences[selectedSound][currentPattern][selectedExtraStep]) {
      extraSubSequences[selectedSound][currentPattern][selectedExtraStep] = Array(32).fill(false);
      extraSubSequences[selectedSound][currentPattern][selectedExtraStep][0] = true;
    }
  } else {
    if (isVariationSubsequencer) {
      variationSubstepCounts[selectedSound][currentPattern] = count;
      if (!variationSubSequences[selectedSound][currentPattern]) {
        variationSubSequences[selectedSound][currentPattern] = Array(32).fill(false);
        variationSubSequences[selectedSound][currentPattern][0] = true;
      } else {
        const newSequence = Array(32).fill(false);
        for (let i = 0; i < Math.min(variationSubSequences[selectedSound][currentPattern].length, count); i++) {
          newSequence[i] = variationSubSequences[selectedSound][currentPattern][i] || false;
        }
        if (!newSequence.some(step => step)) {
          newSequence[0] = true;
        }
        variationSubSequences[selectedSound][currentPattern] = newSequence;
      }
    } else {
      mainSubstepCounts[selectedSound][currentPattern] = count;
      if (!mainSubSequences[selectedSound][currentPattern]) {
        mainSubSequences[selectedSound][currentPattern] = Array(32).fill(false);
        mainSubSequences[selectedSound][currentPattern][0] = true;
      } else {
        const newSequence = Array(32).fill(false);
        for (let i = 0; i < Math.min(mainSubSequences[selectedSound][currentPattern].length, count); i++) {
          newSequence[i] = mainSubSequences[selectedSound][currentPattern][i] || false;
        }
        if (!newSequence.some(step => step)) {
          newSequence[0] = true;
        }
        mainSubSequences[selectedSound][currentPattern] = newSequence;
      }
    }
  }
  substepsInput.value = count;
  updateSubSteps(selectedSound);
};

const delayMixInput = document.getElementById("delayMixInput");
delayMixInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  let mixValue = parseFloat(delayMixInput.value);
  if (isNaN(mixValue) || mixValue < 0) mixValue = 0;
  if (mixValue > 1) mixValue = 1;
  delayMixInput.value = mixValue;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayMix[selectedSound][currentPattern][selectedExtraStep] = mixValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const { delay } = extraEffectNodesCache[selectedSound][currentPattern][selectedExtraStep];
      delay.wet.setValueAtTime(mixValue, Tone.now());
    }
  } else if (isVariationSubsequencer) {
    variationDelayMix[selectedSound][currentPattern] = mixValue;
    variationDelays[selectedSound].wet.setValueAtTime(mixValue, Tone.now());
    variationDelayGains[selectedSound].gain.setValueAtTime(mixValue * 0.8, Tone.now());
  } else {
    mainDelayMix[selectedSound][currentPattern] = mixValue;
    mainDelays[selectedSound].wet.setValueAtTime(mixValue, Tone.now());
    mainDelayGains[selectedSound].gain.setValueAtTime(mixValue * 0.8, Tone.now());
  }
});
delayMixInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  delayMixInput.value = 0;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayMix[selectedSound][currentPattern][selectedExtraStep] = 0;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayMix[selectedSound][currentPattern] = 0;
    variationDelays[selectedSound].wet.value = 1;
    variationDelayGains[selectedSound].gain.value = 0;
  } else {
    mainDelayMix[selectedSound][currentPattern] = 0;
    mainDelays[selectedSound].wet.value = 1;
    mainDelayGains[selectedSound].gain.value = 0;
  }
});

delayFeedbackInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  let feedbackValue = parseFloat(delayFeedbackInput.value);
  if (isNaN(feedbackValue) || feedbackValue < 0) feedbackValue = 0;
  if (feedbackValue > 0.95) feedbackValue = 0.95;
  delayFeedbackInput.value = feedbackValue;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] = feedbackValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: feedbackValue,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayFeedback[selectedSound][currentPattern] = feedbackValue;
    variationDelays[selectedSound].feedback.value = feedbackValue;
  } else {
    mainDelayFeedback[selectedSound][currentPattern] = feedbackValue;
    mainDelays[selectedSound].feedback.value = feedbackValue;
  }
});
delayFeedbackInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  delayFeedbackInput.value = 0.3;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] = 0.3;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayFeedback[selectedSound][currentPattern] = 0.3;
    variationDelays[selectedSound].feedback.value = 0.3;
  } else {
    mainDelayFeedback[selectedSound][currentPattern] = 0.3;
    mainDelays[selectedSound].feedback.value = 0.3;
  }
});

delayTimeInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  let timeValue = parseInt(delayTimeInput.value, 10);
  if (isNaN(timeValue) || timeValue < 0) timeValue = 0;
  if (timeValue > 15) timeValue = 15;
  delayTimeInput.value = timeValue;
  const subdivision = subdivisions[timeValue]?.time || "4n";
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayTime[selectedSound][currentPattern][selectedExtraStep] = timeValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivision,
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayTime[selectedSound][currentPattern] = timeValue;
    variationDelays[selectedSound].delayTime.value = subdivision;
  } else {
    mainDelayTime[selectedSound][currentPattern] = timeValue;
    mainDelays[selectedSound].delayTime.value = subdivision;
  }
});
delayTimeInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  delayTimeInput.value = 3;
  const subdivision = subdivisions[3]?.time || "4n";
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayTime[selectedSound][currentPattern][selectedExtraStep] = 3;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivision,
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] || 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayTime[selectedSound][currentPattern] = 3;
    variationDelays[selectedSound].delayTime.value = subdivision;
  } else {
    mainDelayTime[selectedSound][currentPattern] = 3;
    mainDelays[selectedSound].delayTime.value = subdivision;
  }
});

delayFilterInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  let filterValue = parseFloat(delayFilterInput.value);
  if (isNaN(filterValue) || filterValue < 20) filterValue = 20;
  if (filterValue > 22050) filterValue = 22050;
  delayFilterInput.value = filterValue;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] = filterValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: filterValue,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayFilterFreq[selectedSound][currentPattern] = filterValue;
    variationDelayFilters[selectedSound].frequency.value = filterValue;
  } else {
    mainDelayFilterFreq[selectedSound][currentPattern] = filterValue;
    mainDelayFilters[selectedSound].frequency.value = filterValue;
  }
});
delayFilterInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  delayFilterInput.value = 5000;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraDelayFilterFreq[selectedSound][currentPattern][selectedExtraStep] = 5000;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      const player = extraStepSamplers[selectedSound][currentPattern][selectedExtraStep];
      player.disconnect();
      const pitchShift = new Tone.PitchShift({
        pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0,
        wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 1
      });
      const distortion = new Tone.Distortion({
        distortion: 0.5,
        wet: extraDistortionWet[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delay = new Tone.FeedbackDelay({
        delayTime: subdivisions[extraDelayTime[selectedSound][currentPattern][selectedExtraStep] || 3]?.time || "4n",
        feedback: extraDelayFeedback[selectedSound][currentPattern][selectedExtraStep] || 0.3,
        wet: extraDelayMix[selectedSound][currentPattern][selectedExtraStep] || 0
      });
      const delayFilter = new Tone.Filter({
        frequency: 5000,
        type: "lowpass"
      });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationDelayFilterFreq[selectedSound][currentPattern] = 5000;
    variationDelayFilters[selectedSound].frequency.value = 5000;
  } else {
    mainDelayFilterFreq[selectedSound][currentPattern] = 5000;
    mainDelayFilters[selectedSound].frequency.value = 5000;
  }
});

substepsInput.addEventListener("change", updateSubsteps);
substepsInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    substepsInput.blur();
    updateSubsteps();
  }
});
    
const loop = new Tone.Loop((time) => {
  const anySolo = tracks.some(track => trackSoloStates[track]);
  // Count total active players across all tracks and steps
  let totalActivePlayers = 0;
  tracks.forEach(track => {
    if (activeExtraPlayers[track]) {
      Object.values(activeExtraPlayers[track]).forEach(players => {
        totalActivePlayers += players.length;
      });
    }
  });
  console.log(`Total active players across all tracks: ${totalActivePlayers}`);
  tracks.forEach((track, i) => {
    const stepCount = trackStepCounts[track] || 16;
    if (stepCount === 0) return;
    const stepIndex = globalStepIndex % stepCount;
    trackStepIndices[track] = stepIndex;
    const note = notes[i];
    const trackDiv = sequencerDiv.querySelector(`[data-track="${track}"]`);
    const steps = trackDiv.querySelectorAll(".step");
    steps.forEach((step, j) => {
      const stepNum = parseInt(step.dataset.step);
      step.style.border = stepNum === stepIndex ? "2px solid #ff0" : "1px solid #333";
      step.classList.toggle("measure-highlight", j % measures === 0 && !sequence[track][currentPattern]?.[j] && step.classList.contains("enabled") && !clickActive);
      step.classList.toggle("measure-highlight-active", j % measures === 0 && !sequence[track][currentPattern]?.[j] && step.classList.contains("enabled") && clickActive);
      if (!["extra", "extra2", "extra3", "extra4"].includes(track)) {
        const stepState = sequence[track][currentPattern]?.[j];
        step.classList.toggle("main-active", stepState === true || stepState === "both");
        step.classList.toggle("variation-active", stepState === "variation" || stepState === "both");
      } else {
        step.classList.toggle("main-active", sequence[track][currentPattern]?.[j]);
      }
    });
    if (trackMuteStates[track] || (anySolo && !trackSoloStates[track])) return;
// Inside the loop function, replace the extra track handling section
if (["extra", "extra2", "extra3", "extra4"].includes(track)) {
  if (sequence[track][currentPattern]?.[stepIndex] && extraStepSamplers[track][currentPattern][stepIndex]) {
    const player = extraStepSamplers[track][currentPattern][stepIndex];
    // Check if the player's buffer is valid and loaded
    if (!player.buffer || !player.buffer.loaded) {
      console.warn(`Skipping playback for ${track} track, step ${stepIndex}: Buffer not loaded or invalid`);
      return;
    }

    // Ensure effect nodes are cached
    if (!extraEffectNodesCache[track][currentPattern][stepIndex]) {
      extraEffectNodesCache[track][currentPattern][stepIndex] = {
        pitchShift: new Tone.PitchShift({ pitch: extraPitch[track][currentPattern][stepIndex] || 0, wet: extraPitchMix[track][currentPattern][stepIndex] || 1 }),
        distortion: new Tone.Distortion({ distortion: 0.5, wet: extraDistortionWet[track][currentPattern][stepIndex] || 0 }),
        delay: new Tone.FeedbackDelay({
          delayTime: subdivisions[extraDelayTime[track][currentPattern][stepIndex] || 3]?.time || "4n",
          feedback: extraDelayFeedback[track][currentPattern][stepIndex] || 0.3,
          wet: extraDelayMix[track][currentPattern][stepIndex] || 0
        }),
        delayFilter: new Tone.Filter({ frequency: extraDelayFilterFreq[track][currentPattern][stepIndex] || 5000, type: "lowpass" }),
        panner: new Tone.Panner(extraPanning[track][currentPattern][stepIndex] || 0),
        gain: new Tone.Gain(extraVolumes[track][currentPattern][stepIndex] || 0.8)
      };
    }

    const { pitchShift, distortion, delay, delayFilter, panner, gain } = extraEffectNodesCache[track][currentPattern][stepIndex];

    // Update effect parameters
    pitchShift.pitch = extraPitch[track][currentPattern][stepIndex] || 0;
    pitchShift.wet.setValueAtTime(extraPitchMix[track][currentPattern][stepIndex] || 1, time);
    distortion.wet.setValueAtTime(extraDistortionWet[track][currentPattern][stepIndex] || 0, time);
    delay.delayTime.setValueAtTime(subdivisions[extraDelayTime[track][currentPattern][stepIndex] || 3]?.time || "4n", time);
    delay.feedback.setValueAtTime(extraDelayFeedback[track][currentPattern][stepIndex] || 0.3, time);
    delay.wet.setValueAtTime(extraDelayMix[track][currentPattern][stepIndex] || 0, time);
    delayFilter.frequency.setValueAtTime(extraDelayFilterFreq[track][currentPattern][stepIndex] || 5000, time);
    panner.pan.setValueAtTime(extraPanning[track][currentPattern][stepIndex] || 0, time);
    gain.gain.setValueAtTime(extraVolumes[track][currentPattern][stepIndex] || 0.8, time);

    // Connect player to effect chain
    player.disconnect();
    player.chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);

    const mode = extraMonoPoly[track][currentPattern] || "step";
    const quarterNoteDuration = Tone.Time("4n").toSeconds();
    const subSequence = extraSubSequences[track][currentPattern]?.[stepIndex] || Array(32).fill(false);
    const substepCount = extraSubstepCounts[track][currentPattern]?.[stepIndex] || 1;
    const substepDuration = quarterNoteDuration / substepCount;

    // Initialize active players for this track and step
    if (!activeExtraPlayers[track]) activeExtraPlayers[track] = {};
    if (!activeExtraPlayers[track][stepIndex]) activeExtraPlayers[track][stepIndex] = [];

    // Clear previous players for this step to prevent overlap
    activeExtraPlayers[track][stepIndex].forEach(p => {
      if (p.state === "started") p.stop(time);
      p.dispose();
    });
    activeExtraPlayers[track][stepIndex] = [];

    if (mode === "step") {
      // STEP: Play for each active substep with new player instances
      for (let j = 0; j < substepCount; j++) {
        if (subSequence[j]) {
          const subTime = time + j * substepDuration;
          const newPlayer = new Tone.Player({
            url: player.buffer.get(),
            autostart: false
          }).chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
          newPlayer.start(subTime).stop(subTime + substepDuration);
          activeExtraPlayers[track][stepIndex].push(newPlayer);
          if (track === selectedSound && selectedExtraStep === stepIndex) {
            const substepEl = secondaryTrackDiv.querySelector(`[data-step="${j}"]`);
            if (substepEl) {
              substepEl.classList.add("active", "extra-active");
              setTimeout(() => {
                if (substepEl) {
                  substepEl.classList.toggle("active", subSequence[j]);
                  substepEl.classList.toggle("extra-active", subSequence[j]);
                }
              }, substepDuration * 1000);
            }
          }
        }
      }
    } else if (mode === "next") {
      // NEXT: Stop all other players in this track, play until next sound
      Object.keys(activeExtraPlayers[track]).forEach(key => {
        if (key != stepIndex) {
          activeExtraPlayers[track][key].forEach(p => {
            if (p.state === "started") p.stop(time);
            p.dispose();
          });
          activeExtraPlayers[track][key] = [];
        }
      });
      for (let j = 0; j < substepCount; j++) {
        if (subSequence[j]) {
          const subTime = time + j * substepDuration;
          const newPlayer = new Tone.Player({
            url: player.buffer.get(),
            autostart: false
          }).chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
          newPlayer.start(subTime);
          activeExtraPlayers[track][stepIndex].push(newPlayer);
          if (track === selectedSound && selectedExtraStep === stepIndex) {
            const substepEl = secondaryTrackDiv.querySelector(`[data-step="${j}"]`);
            if (substepEl) {
              substepEl.classList.add("active", "extra-active");
              setTimeout(() => {
                if (substepEl) {
                  substepEl.classList.toggle("active", subSequence[j]);
                  substepEl.classList.toggle("extra-active", subSequence[j]);
                }
              }, substepDuration * 1000);
            }
          }
        }
      }
    } else if (mode === "full") {
      // FULL: Play the entire sample without stopping
      for (let j = 0; j < substepCount; j++) {
        if (subSequence[j]) {
          const subTime = time + j * substepDuration;
          const newPlayer = new Tone.Player({
            url: player.buffer.get(),
            autostart: false
          }).chain(pitchShift, distortion, delay, delayFilter, panner, gain, Tone.Destination);
          newPlayer.start(subTime);
          activeExtraPlayers[track][stepIndex].push(newPlayer);
          if (track === selectedSound && selectedExtraStep === stepIndex) {
            const substepEl = secondaryTrackDiv.querySelector(`[data-step="${j}"]`);
            if (substepEl) {
              substepEl.classList.add("active", "extra-active");
              setTimeout(() => {
                if (substepEl) {
                  substepEl.classList.toggle("active", subSequence[j]);
                  substepEl.classList.toggle("extra-active", subSequence[j]);
                }
              }, substepDuration * 1000);
            }
          }
        }
      }
    }
  // console.log(`Active players for ${track} track, step ${stepIndex}: ${activeExtraPlayers[track][stepIndex].length}`);
  }
    } else {
      const stepState = sequence[track][currentPattern]?.[stepIndex];
      if (stepState) {
        const playMain = stepState === true || stepState === "both";
        const playVariation = stepState === "variation" || stepState === "both";
        const modes = [];
        if (playMain) modes.push(false);
        if (playVariation) modes.push(true);
        modes.forEach(isVariation => {
          samplers[track].disconnect();
          const panner = isVariation ? variationPanners[track] : mainPanners[track];
          const gain = isVariation ? variationGains[track] : mainGains[track];
          const pitchShift = isVariation ? variationPitchShifters[track] : mainPitchShifters[track];
          const distortion = isVariation ? variationDistortions[track] : mainDistortions[track];
          const delay = isVariation ? variationDelays[track] : mainDelays[track];
          const delayGain = isVariation ? variationDelayGains[track] : mainDelayGains[track];
          samplers[track].chain(panner, gain, pitchShift, distortion, delay, delayGain, Tone.Destination);
          const subSequence = isVariation ? variationSubSequences[track][currentPattern] : mainSubSequences[track][currentPattern];
          const substepCount = isVariation ? variationSubstepCounts[track][currentPattern] : mainSubstepCounts[track][currentPattern];
          const playMode = isVariation ? variationMonoPoly[track][currentPattern] : mainMonoPoly[track][currentPattern];
          if (substepCount > 0 && loadedSamples[note] && samplers[track].loaded) {
            const quarterNoteDuration = Tone.Time("4n").toSeconds();
            const substepDuration = quarterNoteDuration / substepCount;
            const noteDuration = substepCount === 3 ? "8t" : substepCount === 8 ? "32n" : substepCount === 16 ? "64n" : `${substepCount * 4}n`;
            for (let j = 0; j < substepCount; j++) {
              if (subSequence?.[j]) {
                const subTime = time + j * substepDuration;
                if (playMode === "mono") {
                  samplers[track].triggerRelease(subTime);
                  samplers[track].triggerAttackRelease(note, noteDuration, subTime);
                } else if (playMode === "poly") {
                  samplers[track].triggerAttack(note, subTime);
                } else if (playMode === "full") {
                  const sampleUrl = loadedSamples[note];
                  if (sampleUrl) {
                    const player = new Tone.Player({
                      url: sampleUrl,
                      autostart: false,
                      volume: isVariation ? variationVolumes[track][currentPattern] : mainVolumes[track][currentPattern],
                      onload: () => {
                        player.start(subTime);
                        player.onended = () => {
                          if (player.state === "started") {
                            player.stop();
                          }
                          player.dispose();
                        };
                      },
                      onerror: (error) => console.error(`Failed to load sample for ${track}: ${error}`)
                    });
                    player.chain(panner, gain, pitchShift, distortion, delay, delayGain, Tone.Destination);
                  }
                }
                if (track === selectedSound && isVariation === isVariationSubsequencer) {
                  const substepEl = secondaryTrackDiv.querySelector(`[data-step="${j}"]`);
                  if (substepEl) {
                    substepEl.classList.add("active");
                    substepEl.classList.toggle("main-active", !isVariationSubsequencer);
                    substepEl.classList.toggle("variation-active", isVariationSubsequencer);
                    setTimeout(() => {
                      if (substepEl) {
                        substepEl.classList.toggle("active", subSequence[j]);
                        substepEl.classList.toggle("main-active", subSequence[j] && !isVariationSubsequencer);
                        substepEl.classList.toggle("variation-active", subSequence[j] && isVariationSubsequencer);
                      }
                    }, substepDuration * 1000);
                  }
                }
              }
            }
          }
        });
      }
    }
  });
  if (clickActive) {
    if (clickSample && clickSampler.loaded) {
      clickSampler.triggerAttackRelease("C3", "8n", time);
    } else {
      let isPinkSquare = false;
      tracks.forEach(track => {
        const stepCount = trackStepCounts[track] || 16;
        if (stepCount === 0) return;
        const stepIndex = globalStepIndex % stepCount;
        const stepEl = sequencerDiv.querySelector(`[data-track="${track}"][data-step="${stepIndex}"]`);
        if (stepEl && (stepEl.classList.contains("measure-highlight") || stepEl.classList.contains("measure-highlight-active"))) {
          isPinkSquare = true;
        }
      });
      if (isPinkSquare) {
        clickSynth.triggerAttackRelease("C3", "8n", time);
      } else {
        accentClickSynth.triggerAttackRelease("C3", "8n", time);
      }
    }
  }
  globalStepIndex++;
}, "4n").start(0);

async function toggleSequencer() {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  if (!isPlaying) {
    tracks.forEach(track => refreshPannerConnections(track, false));
    Tone.Transport.start();
    isPlaying = true;
    document.getElementById("playButton").classList.add("playing");
  } else {
    Tone.Transport.stop();
    isPlaying = false;
    globalStepIndex = 0;
    tracks.forEach(track => trackStepIndices[track] = 0);
    // Comprehensive cleanup for extra tracks
    tracks.filter(t => ["extra", "extra2", "extra3", "extra4"].includes(t)).forEach(track => {
      Object.keys(activeExtraPlayers[track] || {}).forEach(step => {
        activeExtraPlayers[track][step].forEach(p => {
          if (p.state === "started") p.stop();
          p.dispose();
        });
        activeExtraPlayers[track][step] = [];
      });
      // Dispose of effect nodes
      Object.keys(extraEffectNodesCache[track][currentPattern] || {}).forEach(step => {
        const { pitchShift, distortion, delay, delayFilter, panner, gain } = extraEffectNodesCache[track][currentPattern][step];
        pitchShift.dispose();
        distortion.dispose();
        delay.dispose();
        delayFilter.dispose();
        panner.dispose();
        gain.dispose();
        delete extraEffectNodesCache[track][currentPattern][step];
      });
    });
    document.querySelectorAll(".step").forEach(step => step.style.border = "1px solid #333");
    if (selectedSound) {
      updateSubSteps(selectedSound);
      updateSoundSettingsUI();
      refreshPannerConnections(selectedSound, isVariationSubsequencer);
    }
    tracks.forEach(track => updateTrackSteps(track, trackStepCounts[track]));
    document.getElementById("playButton").classList.remove("playing");
  }
}

document.getElementById("playButton").addEventListener("click", toggleSequencer);

const stepsInput = document.getElementById("stepsInput");
const updateGlobalSteps = () => {
  let steps = parseInt(stepsInput.value, 10);
  if (isNaN(steps)) {
    stepsInput.value = 16;
    tracks.forEach(track => {
      if (!trackStepLocks[track]) {
        patternStepCounts[track][currentPattern] = 16;
        trackStepCounts[track] = 16;
        updateTrackSteps(track, 16);
      }
    });
    return;
  }
  if (steps < 0) steps = 0;
  if (steps > 32) steps = 32;
  stepsInput.value = steps;
  tracks.forEach(track => {
    if (!trackStepLocks[track]) {
      patternStepCounts[track][currentPattern] = steps;
      trackStepCounts[track] = steps;
      document.querySelector(`.track-steps-input[data-sound="${track}"]`).value = steps;
      updateTrackSteps(track, steps);
    }
  });
};
stepsInput.addEventListener("change", updateGlobalSteps);
stepsInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    stepsInput.blur();
    updateGlobalSteps();
  }
});

  document.querySelectorAll(".track-steps-input").forEach(input => {
    input.addEventListener("change", () => {
      if (!audioStarted) {
        alert("Please click 'Start Audio' first!");
        return;
      }
      const track = input.dataset.sound;
      let steps = parseInt(input.value, 10);
      if (isNaN(steps)) {
        input.value = 16;
        patternStepCounts[track][currentPattern] = 16;
        trackStepCounts[track] = 16;
        updateTrackSteps(track, 16);
        return;
      }
      if (steps < 0) steps = 0;
      if (steps > 32) steps = 32;
      input.value = steps;
      patternStepCounts[track][currentPattern] = steps;
      trackStepCounts[track] = steps;
      updateTrackSteps(track, steps);
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        input.blur();
      }
    });
  });

bpmInput.addEventListener("change", () => {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  let bpm = parseInt(bpmInput.value, 10);
  if (isNaN(bpm)) {
    bpmInput.value = patternBPMs[currentPattern] || 120;
    Tone.Transport.bpm.value = patternBPMs[currentPattern] || 120;
    return;
  }
  if (bpm < 30) bpm = 30;
  if (bpm > 400) bpm = 400;
  patternBPMs[currentPattern] = bpm;
  Tone.Transport.bpm.value = bpm;
  bpmInput.value = bpm;
});
bpmInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    bpmInput.blur();
    bpmInput.dispatchEvent(new Event("change"));
  }
});

document.getElementById("exportPatternButton").addEventListener("click", async () => {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  await exportPatternToWav();
});    
    
function updateSongSteps(row, input) {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  let count = parseInt(input.value, 10);
  if (isNaN(count)) count = 0;
  if (count < 0) count = 0;
  if (count > 16) count = 16;
  input.value = count;

  const rowIndex = parseInt(row.dataset.row);
  const existingSteps = row.querySelectorAll(".song-step-container");
  existingSteps.forEach(step => step.remove());

  for (let i = 0; i < count; i++) {
    const stepContainer = document.createElement("div");
    stepContainer.className = "song-step-container";
    const step = document.createElement("div");
    step.className = "song-step";
    step.dataset.step = i;
    step.dataset.tooltip = `Song step ${i + 1}`;
    const stepKey = `${rowIndex}-${i}`;
    if (songStepAssignments[stepKey]) {
      step.textContent = songStepAssignments[stepKey];
      const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[stepKey]}"]`);
      if (patternBox) {
        const baseColor = getPatternBaseColor(patternBox);
        step.style.backgroundColor = baseColor;
      }
    } else {
      step.style.backgroundColor = "#808080";
    }
    stepContainer.appendChild(step);
    const deleteButton = document.createElement("button");
    deleteButton.className = "delete-step-button";
    deleteButton.textContent = "DELETE";
    deleteButton.dataset.tooltip = `Delete song step ${i + 1}`;
    deleteButton.addEventListener("click", () => deleteStep(row, i));
    stepContainer.appendChild(deleteButton);
    row.appendChild(stepContainer);
  }

  const steps = row.querySelectorAll(".song-step");
  steps.forEach(step => {
    step.removeEventListener("click", step.clickHandler);
    step.clickHandler = () => {
      selectSongStep(step, row);
    };
    step.addEventListener("click", step.clickHandler);
    step.removeEventListener("contextmenu", step.contextMenuHandler);
    step.contextMenuHandler = (e) => {
      e.preventDefault();
      const stepIndex = step.dataset.step;
      const rowIndex = row.dataset.row;
      const fullIndex = `${rowIndex}-${stepIndex}`;
      if (songStepAssignments[fullIndex]) {
        delete songStepAssignments[fullIndex];
        step.textContent = "";
        step.style.backgroundColor = "#808080";
      }
    };
    step.addEventListener("contextmenu", step.contextMenuHandler);
  });
}

function deleteStep(row, stepIndex) {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const steps = row.querySelectorAll(".song-step");
  if (steps.length <= 1) {
    alert("You can't delete the last step in a row!");
    return;
  }
  const stepContainer = steps[stepIndex].parentElement;
  stepContainer.remove();
  for (let i = stepIndex; i < steps.length - 1; i++) {
    songStepAssignments[i] = songStepAssignments[i + 1];
  }
  delete songStepAssignments[steps.length - 1];
  const input = row.querySelector(".song-steps-input");
  input.value = parseInt(input.value) - 1;
  updateSongSteps(row, input);
}

updatePatternDisplay();
document.querySelector(".add-row-button").addEventListener("click", addNewRow);
document.querySelector(".song-steps-input").parentElement.dataset.row = "0";
document.querySelector(".song-steps-input").addEventListener("change", () => updateSongSteps(document.querySelector(".song-steps-input").parentElement, document.querySelector(".song-steps-input")));
document.querySelector(".song-steps-input").addEventListener("keydown", (e) => {
  const firstLoopCountInput = document.querySelector(".loop-count-input");
firstLoopCountInput.addEventListener("change", () => {
  let value = firstLoopCountInput.value.replace(/[^0-9]/g, "");
  let count = parseInt(value, 10);
  if (isNaN(count) || count < 1) count = 1;
  if (count > 128) count = 128;
  firstLoopCountInput.value = count;
  firstLoopCountInput.dataset.original = count;
});
firstLoopCountInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    firstLoopCountInput.blur();
    firstLoopCountInput.dispatchEvent(new Event("change"));
  }
});
  if (e.key === "Enter") {
    e.preventDefault();
    document.querySelector(".song-steps-input").blur();
    updateSongSteps(document.querySelector(".song-steps-input").parentElement, document.querySelector(".song-steps-input"));
  }
});

function updateDeleteRowButtons() {
  const songSequencerContainer = document.getElementById("songSequencerContainer");
  const rows = songSequencerContainer.querySelectorAll(".pattern-row");
  const deleteRowButtons = songSequencerContainer.querySelectorAll(".delete-row-button");
  if (rows.length === 1) {
    deleteRowButtons.forEach(button => {
      button.style.display = "none";
    });
  } else {
    deleteRowButtons.forEach(button => {
      button.style.display = "inline-block";
    });
  }
}

// Add a new row to the Song Sequencer with a play button
function addNewRow(event) {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const songSequencerContainer = document.getElementById("songSequencerContainer");
  const rows = songSequencerContainer.querySelectorAll(".pattern-row");
  if (rows.length >= 16) {
    alert("Maximum 16 rows reached!");
    return;
  }
  const clickedRow = event.target.closest(".pattern-row");
  const clickedRowIndex = parseInt(clickedRow.dataset.row);
  const newRowIndex = clickedRowIndex + 1;
  const newRow = document.createElement("div");
  newRow.className = "pattern-row";
  newRow.dataset.row = newRowIndex;
  newRow.innerHTML = `
    <button class="song-play-button" data-tooltip="Play song from this row"></button>
    <span class="loop-label">LOOP:</span>
    <div class="loop-toggle" data-state="off" data-tooltip="Toggle loop on (green) or off (red)"></div>
    <input type="text" class="loop-count-input" value="1" data-tooltip="Set loop count (1-128) or shows current/total during playback">
    <button class="add-row-button" data-tooltip="Add a new row">ADD ROW</button>
    <button class="delete-row-button" data-tooltip="Delete this row" style="display: inline-block;">DELETE</button>
    <span class="steps-label">STEPS:</span>
    <input type="number" class="song-steps-input" min="0" max="16" step="1" value="0" data-tooltip="Set song steps (0-16)">
  `;
  if (clickedRow.nextSibling) {
    songSequencerContainer.insertBefore(newRow, clickedRow.nextSibling);
  } else {
    songSequencerContainer.appendChild(newRow);
  }

  // Update row indices and song step assignments
  const maxRow = rows.length;
  for (let oldRow = maxRow; oldRow > newRowIndex; oldRow--) {
    for (let step = 0; step < 16; step++) {
      const oldKey = `${oldRow - 1}-${step}`;
      const newKey = `${oldRow}-${step}`;
      if (oldKey in songStepAssignments) {
        songStepAssignments[newKey] = songStepAssignments[oldKey];
        delete songStepAssignments[oldKey];
      }
    }
  }
  const allRows = songSequencerContainer.querySelectorAll(".pattern-row");
  allRows.forEach((row, index) => {
    row.dataset.row = index;
  });

  // Attach event listeners to new row elements
  const newSongStepsInput = newRow.querySelector(".song-steps-input");
  updateSongSteps(newRow, newSongStepsInput);
  newSongStepsInput.addEventListener("change", () => updateSongSteps(newRow, newSongStepsInput));
  newSongStepsInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      newSongStepsInput.blur();
      updateSongSteps(newRow, newSongStepsInput);
    }
  });

  const newLoopToggle = newRow.querySelector(".loop-toggle");
  newLoopToggle.addEventListener("click", () => {
    const isOn = newLoopToggle.dataset.state === "off";
    newLoopToggle.dataset.state = isOn ? "on" : "off";
    newLoopToggle.classList.toggle("on", isOn);
  });

  const newLoopCountInput = newRow.querySelector(".loop-count-input");
  newLoopCountInput.addEventListener("change", () => {
    let value = newLoopCountInput.value.replace(/[^0-9]/g, "");
    let count = parseInt(value, 10);
    if (isNaN(count) || count < 1) count = 1;
    if (count > 128) count = 128;
    newLoopCountInput.value = count;
    newLoopCountInput.dataset.original = count;
  });
  newLoopCountInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      newLoopCountInput.blur();
      newLoopCountInput.dispatchEvent(new Event("change"));
    }
  });

  const deleteRowButton = newRow.querySelector(".delete-row-button");
  deleteRowButton.addEventListener("click", () => {
    const songSequencerContainer = document.getElementById("songSequencerContainer");
    const currentRows = songSequencerContainer.querySelectorAll(".pattern-row");
    if (currentRows.length <= 1) {
      alert("You can't delete the last row!");
      return;
    }
    const deletedRowIndex = parseInt(newRow.dataset.row);
    newRow.remove();
    for (let step = 0; step < 16; step++) {
      delete songStepAssignments[`${deletedRowIndex}-${step}`];
    }
    const maxRow = currentRows.length - 1;
    for (let oldRow = deletedRowIndex + 1; oldRow <= maxRow; oldRow++) {
      for (let step = 0; step < 16; step++) {
        const oldKey = `${oldRow}-${step}`;
        const newKey = `${oldRow - 1}-${step}`;
        if (oldKey in songStepAssignments) {
          songStepAssignments[newKey] = songStepAssignments[oldKey];
          delete songStepAssignments[oldKey];
        }
      }
    }
    const remainingRows = songSequencerContainer.querySelectorAll(".pattern-row");
    remainingRows.forEach((row, index) => {
      row.dataset.row = index;
    });
    updateDeleteRowButtons();
  });

  const newAddRowButton = newRow.querySelector(".add-row-button");
  newAddRowButton.addEventListener("click", addNewRow);

  // Attach event listener to the new play button
  const newPlayButton = newRow.querySelector(".song-play-button");
  newPlayButton.addEventListener("click", async () => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    if (!isPlaying) {
      const rowIndex = parseInt(newRow.dataset.row);
      const firstStep = newRow.querySelector(".song-step");
      const stepIndex = parseInt(firstStep.dataset.step);
      const fullIndex = `${rowIndex}-${stepIndex}`;
      const firstPattern = songStepAssignments[fullIndex];
      if (!firstPattern || !patterns.includes(firstPattern)) {
        alert("Please assign a valid pattern to the first grey square in this row!");
        return;
      }

      isPlaying = true;
      document.getElementById("playButton").classList.add("playing");
      newPlayButton.classList.add("playing");
      await playSongSequence(rowIndex);
    } else {
      resetPlaybackState();
    }
  });

  updateDeleteRowButtons();
}

const songStepAssignments = {};
function selectSongStep(step, row) {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  const stepIndex = parseInt(step.dataset.step);
  const rowIndex = parseInt(row.dataset.row);
  const fullIndex = `${rowIndex}-${stepIndex}`;
  
  if (step.classList.contains("selected")) {
    step.classList.remove("selected");
    step.style.border = "1px solid #333";
    step.textContent = songStepAssignments[fullIndex] || "";
    const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[fullIndex]}"]`);
    step.style.backgroundColor = patternBox ? getPatternBaseColor(patternBox) : "#808080";
  } else {
    document.querySelectorAll(".song-step").forEach(s => {
      s.classList.remove("selected");
      s.style.border = "1px solid #333";
      const sRow = s.closest(".pattern-row").dataset.row;
      const sStep = s.dataset.step;
      const sFullIndex = `${sRow}-${sStep}`;
      s.textContent = songStepAssignments[sFullIndex] || "";
      const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[sFullIndex]}"]`);
      s.style.backgroundColor = patternBox ? getPatternBaseColor(patternBox) : "#808080";
    });
    
    step.classList.add("selected");
    step.style.border = "2px solid #fff";
    if (songStepAssignments[fullIndex]) {
      step.textContent = songStepAssignments[fullIndex];
      const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[fullIndex]}"]`);
      step.style.backgroundColor = patternBox ? getPatternBaseColor(patternBox) : "#808080";
    }
  }
}

document.getElementById("songSequencerContainer").addEventListener("click", (e) => {
  if (!audioStarted) return;
  if (e.target.classList.contains("song-step")) return;
  document.querySelectorAll(".song-step").forEach(step => {
    step.classList.remove("selected");
    step.style.border = "1px solid #333";
    const rowIndex = step.closest(".pattern-row").dataset.row;
    const stepIndex = step.dataset.step;
    const fullIndex = `${rowIndex}-${stepIndex}`;
    step.textContent = songStepAssignments[fullIndex] || "";
    const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[fullIndex]}"]`);
    step.style.backgroundColor = patternBox ? getPatternBaseColor(patternBox) : "#808080";
  });
});  
    
function getPatternBaseColor(patternBox) {
  const computedStyle = getComputedStyle(patternBox);
  return computedStyle.backgroundColor;
}

document.querySelectorAll(".pattern-box").forEach(box => {
  box.addEventListener("click", (e) => {
    if (!audioStarted) {
      alert("Please click 'Start Audio' first!");
      return;
    }
    if (!patterns.includes(box.dataset.pattern)) return;
    document.querySelectorAll(".pattern-box").forEach(b => {
      b.classList.remove("selected");
      const baseColor = getPatternBaseColor(b);
      if (!b.classList.contains("deactivated")) {
        b.style.backgroundColor = baseColor;
      }
    });
    box.classList.add("selected");
    const baseColor = getPatternBaseColor(box);
    box.style.backgroundColor = baseColor;
    const patternDisplay = document.getElementById("patternDisplay");
    patternDisplay.style.backgroundColor = baseColor;
    const selectedStep = document.querySelector(".song-step.selected");
    if (selectedStep) {
      const stepIndex = selectedStep.dataset.step;
      const rowIndex = selectedStep.closest(".pattern-row").dataset.row;
      const fullIndex = `${rowIndex}-${stepIndex}`;
      const pattern = box.dataset.pattern;
      songStepAssignments[fullIndex] = pattern;
      selectedStep.textContent = pattern;
      selectedStep.style.backgroundColor = baseColor;
      const row = selectedStep.closest(".pattern-row");
      let nextStep = row.querySelector(`.song-step[data-step="${parseInt(stepIndex) + 1}"]`);
      if (!nextStep) {
        const nextRow = row.nextElementSibling;
        if (nextRow && nextRow.classList.contains("pattern-row")) {
          nextStep = nextRow.querySelector(".song-step[data-step='0']");
        }
      }
      if (nextStep) {
        document.querySelectorAll(".song-step").forEach(s => {
          s.classList.remove("selected");
          s.style.border = "1px solid #333";
        });
        nextStep.classList.add("selected");
        nextStep.style.border = "2px solid #fff";
        const nextRowIndex = nextStep.closest(".pattern-row").dataset.row;
        const nextStepIndex = nextStep.dataset.step;
        const nextFullIndex = `${nextRowIndex}-${nextStepIndex}`;
        if (songStepAssignments[nextFullIndex]) {
          nextStep.textContent = songStepAssignments[nextFullIndex];
          const nextPatternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[nextFullIndex]}"]`);
          nextStep.style.backgroundColor = nextPatternBox ? getPatternBaseColor(nextPatternBox) : "#808080";
        } else {
          nextStep.textContent = "";
          nextStep.style.backgroundColor = "#808080";
        }
      }
    }
  });
});

document.getElementById("songPlayButton").addEventListener("click", async () => {
  if (!audioStarted) {
    alert("Please click 'Start Audio' first!");
    return;
  }
  if (!isPlaying) {
    const firstRow = document.querySelector("#songSequencerContainer .pattern-row");
    const firstStep = firstRow.querySelector(".song-step");
    const stepIndex = parseInt(firstStep.dataset.step);
    const rowIndex = parseInt(firstRow.dataset.row);
    const fullIndex = `${rowIndex}-${stepIndex}`;
    const firstPattern = songStepAssignments[fullIndex];
    if (!firstPattern || !patterns.includes(firstPattern)) {
      alert("Please assign a valid pattern to the first grey square in the Song Sequencer!");
      return;
    }

    isPlaying = true;
    document.getElementById("playButton").classList.add("playing");
    document.getElementById("songPlayButton").classList.add("playing");


// Modified playSongSequence to start from a specific row
async function playSongSequence(startRowIndex = 0) {
  document.querySelectorAll(".loop-count-input").forEach(input => {
    input.dataset.original = input.value || "1";
  });

  const rows = document.querySelectorAll("#songSequencerContainer .pattern-row");
  return new Promise(async (resolve) => {
    for (let r = startRowIndex; r < rows.length; r++) {
      const row = rows[r];
      if (!isPlaying) {
        resolve();
        return;
      }
      const rowIndex = parseInt(row.dataset.row);
      const steps = row.querySelectorAll(".song-step");
      const loopCountInput = row.querySelector(".loop-count-input");
      let loopCount = parseInt(loopCountInput.dataset.original) || 1;
      if (isNaN(loopCount) || loopCount < 1) loopCount = 1;
      if (loopCount > 128) loopCount = 128;

      for (let loop = 0; loop < loopCount && isPlaying; loop++) {
        loopCountInput.value = `${loop + 1}/${loopCount}`; 
        for (const step of steps) {
          if (!isPlaying) {
            resolve();
            return;
          }
          const stepIndex = parseInt(step.dataset.step);
          const fullIndex = `${rowIndex}-${stepIndex}`;
          const pattern = songStepAssignments[fullIndex];
          if (!pattern || !patterns.includes(pattern)) continue;

          document.querySelectorAll(".song-step").forEach(s => {
            s.classList.remove("selected");
            s.style.border = "1px solid #333";
            const sRow = s.closest(".pattern-row").dataset.row;
            const sStep = s.dataset.step;
            const sFullIndex = `${sRow}-${sStep}`;
            s.textContent = songStepAssignments[sFullIndex] || "";
            const patternBox = document.querySelector(`.pattern-box[data-pattern="${songStepAssignments[sFullIndex]}"]`);
            s.style.backgroundColor = patternBox ? getPatternBaseColor(patternBox) : "#808080";
          });
          step.classList.add("selected");
          step.style.border = "2px solid #fff";

          currentPattern = pattern;
          globalStepIndex = 0;
          tracks.forEach(track => {
            trackStepIndices[track] = 0;
            const stepCount = patternStepCounts[track][pattern] || 16;
            trackStepCounts[track] = stepCount;
            updateTrackSteps(track, stepCount);
            refreshPannerConnections(track, false);
            refreshPannerConnections(track, true);
          });
          Tone.Transport.bpm.value = patternBPMs[pattern] || 120;
          document.getElementById("bpmInput").value = patternBPMs[pattern] || 120;
          const firstUnlockedTrack = tracks.find(track => !trackStepLocks[track]);
          document.getElementById("stepsInput").value = firstUnlockedTrack ? patternStepCounts[firstUnlockedTrack][pattern] || 16 : 16;
          measures = patternMeasures[pattern] || 4;
          document.getElementById("clickMeasuresInput").value = measures;
          updateClickUI();
          updatePatternDisplay();
          document.querySelectorAll(".pattern-box").forEach(box => {
            box.classList.toggle("selected", box.dataset.pattern === pattern);
          });
          if (selectedSound) {
            updateSubSteps(selectedSound);
            updateSoundSettingsUI();
          }

          const maxSteps = Math.max(...tracks.map(track => trackStepCounts[track] || 16));
          const quarterNoteDuration = Tone.Time("4n").toSeconds();
          const patternDuration = maxSteps * quarterNoteDuration;

          if (!isPlaying) Tone.Transport.stop();
          Tone.Transport.start();
          await new Promise(resolve => setTimeout(resolve, patternDuration * 1000));
        }
      }
      loopCountInput.value = loopCountInput.dataset.original; 
    }
    if (isPlaying) resetPlaybackState();
    resolve();
  });
}

    await playSongSequence();
  } else {
    resetPlaybackState();
  }
});

function resetPlaybackState() {
  Tone.Transport.stop();
  isPlaying = false;
  globalStepIndex = 0;
  tracks.forEach(track => trackStepIndices[track] = 0);
  document.querySelectorAll(".step").forEach(step => step.style.border = "1px solid #333");
  document.querySelectorAll(".song-step").forEach(step => {
    step.classList.remove("selected");
    step.style.border = "1px solid #333";
  });
  document.getElementById("playButton").classList.remove("playing");
  document.getElementById("songPlayButton").classList.remove("playing");
  tracks.forEach(track => updateTrackSteps(track, trackStepCounts[track]));
  if (selectedSound) {
    updateSubSteps(selectedSound);
    updateSoundSettingsUI();
  }
  document.querySelectorAll(".loop-count-input").forEach(input => {
    if (input.dataset.original) {
      input.value = input.dataset.original;
      input.removeAttribute("data-original");
    }
  });
}

updateTrackUI();
updateDeleteRowButtons();
document.querySelector(".delete-row-button").style.display = "none";
updateClickUI();
updatePatternDisplay();  

document.addEventListener("DOMContentLoaded", () => {
  loadWords();
  
  const pitchInput = document.getElementById("pitchInput");
  const pitchMixInput = document.getElementById("pitchMixInput");

pitchInput.addEventListener("change", () => {
  if (!audioStarted || !selectedSound) return;
  let pitchValue = parseInt(pitchInput.value, 10);
  if (isNaN(pitchValue) || pitchValue < -24) pitchValue = -24;
  if (pitchValue > 24) pitchValue = 24;
  pitchInput.value = pitchValue;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraPitch[selectedSound][currentPattern][selectedExtraStep] = pitchValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].disconnect();
      const pitchShift = new Tone.PitchShift({ pitch: pitchValue, wet: extraPitchMix[selectedSound][currentPattern][selectedExtraStep] || 0 });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].chain(pitchShift, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationPitch[selectedSound][currentPattern] = pitchValue;
    variationPitchShifters[selectedSound].pitch = pitchValue;
  } else {
    mainPitch[selectedSound][currentPattern] = pitchValue;
    mainPitchShifters[selectedSound].pitch = pitchValue;
  }
});

pitchMixInput.addEventListener("input", () => {
  if (!audioStarted || !selectedSound) return;
  const mixValue = parseFloat(pitchMixInput.value);
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraPitchMix[selectedSound][currentPattern][selectedExtraStep] = mixValue;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].disconnect();
      const pitchShift = new Tone.PitchShift({ pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0, wet: mixValue });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].chain(pitchShift, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationPitchMix[selectedSound][currentPattern] = mixValue;
    variationPitchShifters[selectedSound].wet.value = mixValue;
  } else {
    mainPitchMix[selectedSound][currentPattern] = mixValue;
    mainPitchShifters[selectedSound].wet.value = mixValue;
  }
});
pitchMixInput.addEventListener("dblclick", () => {
  if (!audioStarted || !selectedSound) return;
  pitchMixInput.value = (selectedSound === "extra") ? 1 : 0;
  if (["extra", "extra2", "extra3", "extra4"].includes(selectedSound) && selectedExtraStep !== null) {
    extraPitchMix[selectedSound][currentPattern][selectedExtraStep] = 1;
    if (extraStepSamplers[selectedSound][currentPattern][selectedExtraStep]) {
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].disconnect();
      const pitchShift = new Tone.PitchShift({ pitch: extraPitch[selectedSound][currentPattern][selectedExtraStep] || 0, wet: 1 });
      const panner = new Tone.Panner(extraPanning[selectedSound][currentPattern][selectedExtraStep] || 0);
      const gain = new Tone.Gain(extraVolumes[selectedSound][currentPattern][selectedExtraStep] || 0.8);
      extraStepSamplers[selectedSound][currentPattern][selectedExtraStep].chain(pitchShift, panner, gain, Tone.Destination);
    }
  } else if (isVariationSubsequencer) {
    variationPitchMix[selectedSound][currentPattern] = 0;
    variationPitchShifters[selectedSound].wet.value = 0;
  } else {
    mainPitchMix[selectedSound][currentPattern] = 0;
    mainPitchShifters[selectedSound].wet.value = 0;
  }
});
});  
</script>    
</body>
</html>
